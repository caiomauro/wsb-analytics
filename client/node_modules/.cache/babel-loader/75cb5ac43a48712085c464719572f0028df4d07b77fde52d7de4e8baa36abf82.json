{"ast":null,"code":"import { jsx as t, jsxs as e } from \"react/jsx-runtime\";\nimport { scaleLinear as i } from \"d3-scale\";\nimport { getValueFormatter as n, useTheme as o, degreesToRadians as r } from \"@nivo/core\";\nimport { computeContinuousColorScaleColorStops as l } from \"@nivo/colors\";\nimport * as a from \"react\";\nimport { Fragment as c, useState as s, useCallback as d, useMemo as h } from \"react\";\nimport g from \"prop-types\";\nvar m = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n    return t(\"circle\", {\n      r: o / 2,\n      cx: i + o / 2,\n      cy: n + o / 2,\n      fill: r,\n      opacity: a,\n      strokeWidth: s,\n      stroke: void 0 === d ? \"transparent\" : d,\n      style: {\n        pointerEvents: \"none\"\n      }\n    });\n  },\n  f = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n    return t(\"g\", {\n      transform: \"translate(\" + i + \",\" + n + \")\",\n      children: t(\"path\", {\n        d: \"\\n                    M\" + o / 2 + \" 0\\n                    L\" + .8 * o + \" \" + o / 2 + \"\\n                    L\" + o / 2 + \" \" + o + \"\\n                    L\" + .2 * o + \" \" + o / 2 + \"\\n                    L\" + o / 2 + \" 0\\n                \",\n        fill: r,\n        opacity: a,\n        strokeWidth: s,\n        stroke: void 0 === d ? \"transparent\" : d,\n        style: {\n          pointerEvents: \"none\"\n        }\n      })\n    });\n  },\n  u = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n    return t(\"rect\", {\n      x: i,\n      y: n,\n      fill: r,\n      opacity: a,\n      strokeWidth: s,\n      stroke: void 0 === d ? \"transparent\" : d,\n      width: o,\n      height: o,\n      style: {\n        pointerEvents: \"none\"\n      }\n    });\n  },\n  v = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n    return t(\"g\", {\n      transform: \"translate(\" + i + \",\" + n + \")\",\n      children: t(\"path\", {\n        d: \"\\n                M\" + o / 2 + \" 0\\n                L\" + o + \" \" + o + \"\\n                L0 \" + o + \"\\n                L\" + o / 2 + \" 0\\n            \",\n        fill: r,\n        opacity: a,\n        strokeWidth: s,\n        stroke: void 0 === d ? \"transparent\" : d,\n        style: {\n          pointerEvents: \"none\"\n        }\n      })\n    });\n  };\nfunction p() {\n  return p = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = arguments[e];\n      for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);\n    }\n    return t;\n  }, p.apply(this, arguments);\n}\nvar y = {\n    length: 200,\n    thickness: 16,\n    direction: \"row\",\n    tickPosition: \"after\",\n    tickSize: 4,\n    tickSpacing: 3,\n    tickOverlap: !1,\n    tickFormat: function (t) {\n      return \"\" + t;\n    },\n    titleAlign: \"start\",\n    titleOffset: 4\n  },\n  b = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  },\n  k = function (t) {\n    var e,\n      i = t.direction,\n      n = t.itemsSpacing,\n      o = t.padding,\n      r = t.itemCount,\n      l = t.itemWidth,\n      a = t.itemHeight;\n    if (\"number\" != typeof o && (\"object\" != typeof (e = o) || Array.isArray(e) || null === e)) throw new Error(\"Invalid property padding, must be one of: number, object\");\n    var c = \"number\" == typeof o ? {\n        top: o,\n        right: o,\n        bottom: o,\n        left: o\n      } : p({}, b, o),\n      s = c.left + c.right,\n      d = c.top + c.bottom,\n      h = l + s,\n      g = a + d,\n      m = (r - 1) * n;\n    return \"row\" === i ? h = l * r + m + s : \"column\" === i && (g = a * r + m + d), {\n      width: h,\n      height: g,\n      padding: c\n    };\n  },\n  x = function (t) {\n    var e = t.anchor,\n      i = t.translateX,\n      n = t.translateY,\n      o = t.containerWidth,\n      r = t.containerHeight,\n      l = t.width,\n      a = t.height,\n      c = i,\n      s = n;\n    switch (e) {\n      case \"top\":\n        c += (o - l) / 2;\n        break;\n      case \"top-right\":\n        c += o - l;\n        break;\n      case \"right\":\n        c += o - l, s += (r - a) / 2;\n        break;\n      case \"bottom-right\":\n        c += o - l, s += r - a;\n        break;\n      case \"bottom\":\n        c += (o - l) / 2, s += r - a;\n        break;\n      case \"bottom-left\":\n        s += r - a;\n        break;\n      case \"left\":\n        s += (r - a) / 2;\n        break;\n      case \"center\":\n        c += (o - l) / 2, s += (r - a) / 2;\n    }\n    return {\n      x: c,\n      y: s\n    };\n  },\n  S = function (t) {\n    var e,\n      i,\n      n,\n      o,\n      r,\n      l,\n      a = t.direction,\n      c = t.justify,\n      s = t.symbolSize,\n      d = t.symbolSpacing,\n      h = t.width,\n      g = t.height;\n    switch (a) {\n      case \"left-to-right\":\n        e = 0, i = (g - s) / 2, o = g / 2, l = \"central\", c ? (n = h, r = \"end\") : (n = s + d, r = \"start\");\n        break;\n      case \"right-to-left\":\n        e = h - s, i = (g - s) / 2, o = g / 2, l = \"central\", c ? (n = 0, r = \"start\") : (n = h - s - d, r = \"end\");\n        break;\n      case \"top-to-bottom\":\n        e = (h - s) / 2, i = 0, n = h / 2, r = \"middle\", c ? (o = g, l = \"alphabetic\") : (o = s + d, l = \"text-before-edge\");\n        break;\n      case \"bottom-to-top\":\n        e = (h - s) / 2, i = g - s, n = h / 2, r = \"middle\", c ? (o = 0, l = \"text-before-edge\") : (o = g - s - d, l = \"alphabetic\");\n    }\n    return {\n      symbolX: e,\n      symbolY: i,\n      labelX: n,\n      labelY: o,\n      labelAnchor: r,\n      labelAlignment: l\n    };\n  },\n  A = function (t) {\n    var e,\n      o = t.scale,\n      r = t.ticks,\n      a = t.length,\n      c = void 0 === a ? y.length : a,\n      s = t.thickness,\n      d = void 0 === s ? y.thickness : s,\n      h = t.direction,\n      g = void 0 === h ? y.direction : h,\n      m = t.tickPosition,\n      f = void 0 === m ? y.tickPosition : m,\n      u = t.tickSize,\n      v = void 0 === u ? y.tickSize : u,\n      p = t.tickSpacing,\n      b = void 0 === p ? y.tickSpacing : p,\n      k = t.tickOverlap,\n      x = void 0 === k ? y.tickOverlap : k,\n      S = t.tickFormat,\n      A = void 0 === S ? y.tickFormat : S,\n      W = t.title,\n      O = t.titleAlign,\n      z = void 0 === O ? y.titleAlign : O,\n      C = t.titleOffset,\n      B = void 0 === C ? y.titleOffset : C,\n      w = \"column\" === g ? [].concat(o.domain()).reverse() : o.domain(),\n      X = i().domain(w);\n    2 === w.length ? X.range([0, c]) : 3 === w.length && X.range([0, c / 2, c]), e = \"thresholds\" in o ? [w[0]].concat(o.thresholds(), [w[1]]) : Array.isArray(r) ? r : o.ticks(r);\n    var Y,\n      H,\n      E,\n      j,\n      T,\n      L,\n      M = l(o, 32),\n      F = n(A),\n      P = [],\n      R = 0,\n      q = 0;\n    if (\"row\" === g) {\n      var V, D, G;\n      Y = c, H = d, q = 1;\n      var I;\n      T = 0, E = \"start\" === z ? 0 : \"middle\" === z ? c / 2 : c, \"before\" === f ? (V = -v, D = x ? d : 0, G = -v - b, I = \"alphabetic\", j = d + B, L = \"hanging\") : (V = x ? 0 : d, G = (D = d + v) + b, I = \"hanging\", j = -B, L = \"alphabetic\"), e.forEach(function (t) {\n        var e = X(t);\n        P.push({\n          x1: e,\n          y1: V,\n          x2: e,\n          y2: D,\n          text: F(t),\n          textX: e,\n          textY: G,\n          textHorizontalAlign: \"middle\",\n          textVerticalAlign: I\n        });\n      });\n    } else {\n      var N, _, J, K;\n      Y = d, H = c, R = 1;\n      T = -90, j = \"start\" === z ? c : \"middle\" === z ? c / 2 : 0, \"before\" === f ? (_ = x ? d : 0, J = (N = -v) - b, K = \"end\", E = d + B, L = \"hanging\") : (N = x ? 0 : d, J = (_ = d + v) + b, K = \"start\", E = -B, L = \"alphabetic\"), e.forEach(function (t) {\n        var e = X(t);\n        P.push({\n          x1: N,\n          y1: e,\n          x2: _,\n          y2: e,\n          text: F(t),\n          textX: J,\n          textY: e,\n          textHorizontalAlign: K,\n          textVerticalAlign: \"central\"\n        });\n      });\n    }\n    return {\n      width: Y,\n      height: H,\n      gradientX1: 0,\n      gradientY1: R,\n      gradientX2: q,\n      gradientY2: 0,\n      colorStops: M,\n      ticks: P,\n      titleText: W,\n      titleX: E,\n      titleY: j,\n      titleRotation: T,\n      titleHorizontalAlign: z,\n      titleVerticalAlign: L\n    };\n  },\n  W = function (i) {\n    var n = i.scale,\n      r = i.ticks,\n      l = i.length,\n      a = void 0 === l ? y.length : l,\n      s = i.thickness,\n      d = void 0 === s ? y.thickness : s,\n      h = i.direction,\n      g = void 0 === h ? y.direction : h,\n      m = i.tickPosition,\n      f = void 0 === m ? y.tickPosition : m,\n      u = i.tickSize,\n      v = void 0 === u ? y.tickSize : u,\n      b = i.tickSpacing,\n      k = void 0 === b ? y.tickSpacing : b,\n      x = i.tickOverlap,\n      S = void 0 === x ? y.tickOverlap : x,\n      W = i.tickFormat,\n      O = void 0 === W ? y.tickFormat : W,\n      z = i.title,\n      C = i.titleAlign,\n      B = void 0 === C ? y.titleAlign : C,\n      w = i.titleOffset,\n      X = A({\n        scale: n,\n        ticks: r,\n        length: a,\n        thickness: d,\n        direction: g,\n        tickPosition: f,\n        tickSize: v,\n        tickSpacing: k,\n        tickOverlap: S,\n        tickFormat: O,\n        title: z,\n        titleAlign: B,\n        titleOffset: void 0 === w ? y.titleOffset : w\n      }),\n      Y = X.width,\n      H = X.height,\n      E = X.gradientX1,\n      j = X.gradientY1,\n      T = X.gradientX2,\n      L = X.gradientY2,\n      M = X.ticks,\n      F = X.colorStops,\n      P = X.titleText,\n      R = X.titleX,\n      q = X.titleY,\n      V = X.titleRotation,\n      D = X.titleVerticalAlign,\n      G = X.titleHorizontalAlign,\n      I = o(),\n      N = \"ContinuousColorsLegendSvgGradient.\" + g + \".\" + F.map(function (t) {\n        return t.offset;\n      }).join(\"_\");\n    return e(\"g\", {\n      children: [t(\"defs\", {\n        children: t(\"linearGradient\", {\n          id: N,\n          x1: E,\n          y1: j,\n          x2: T,\n          y2: L,\n          children: F.map(function (e) {\n            return t(\"stop\", p({}, e));\n          })\n        })\n      }), P && t(\"text\", {\n        transform: \"translate(\" + R + \", \" + q + \") rotate(\" + V + \")\",\n        textAnchor: G,\n        dominantBaseline: D,\n        style: I.legends.title.text,\n        children: P\n      }), t(\"rect\", {\n        width: Y,\n        height: H,\n        fill: \"url(#\" + N\n      }), M.map(function (i, n) {\n        return e(c, {\n          children: [t(\"line\", {\n            x1: i.x1,\n            y1: i.y1,\n            x2: i.x2,\n            y2: i.y2,\n            style: I.legends.ticks.line\n          }), t(\"text\", {\n            x: i.textX,\n            y: i.textY,\n            textAnchor: i.textHorizontalAlign,\n            dominantBaseline: i.textVerticalAlign,\n            style: I.legends.ticks.text,\n            children: i.text\n          })]\n        }, n);\n      })]\n    });\n  },\n  O = [\"containerWidth\", \"containerHeight\", \"anchor\", \"translateX\", \"translateY\", \"length\", \"thickness\", \"direction\"],\n  z = function (e) {\n    var i,\n      n,\n      o = e.containerWidth,\n      r = e.containerHeight,\n      l = e.anchor,\n      a = e.translateX,\n      c = void 0 === a ? 0 : a,\n      s = e.translateY,\n      d = void 0 === s ? 0 : s,\n      h = e.length,\n      g = void 0 === h ? y.length : h,\n      m = e.thickness,\n      f = void 0 === m ? y.thickness : m,\n      u = e.direction,\n      v = void 0 === u ? y.direction : u,\n      b = function (t, e) {\n        if (null == t) return {};\n        var i,\n          n,\n          o = {},\n          r = Object.keys(t);\n        for (n = 0; n < r.length; n++) i = r[n], e.indexOf(i) >= 0 || (o[i] = t[i]);\n        return o;\n      }(e, O);\n    \"row\" === v ? (i = g, n = f) : (i = f, n = g);\n    var k = x({\n        anchor: l,\n        translateX: c,\n        translateY: d,\n        containerWidth: o,\n        containerHeight: r,\n        width: i,\n        height: n\n      }),\n      S = k.x,\n      A = k.y;\n    return t(\"g\", {\n      transform: \"translate(\" + S + \", \" + A + \")\",\n      children: t(W, p({\n        length: g,\n        thickness: f,\n        direction: v\n      }, b))\n    });\n  },\n  C = {\n    circle: m,\n    diamond: f,\n    square: u,\n    triangle: v\n  },\n  B = function (i) {\n    var n,\n      r,\n      l,\n      c,\n      h,\n      g,\n      m,\n      f,\n      u,\n      v,\n      y,\n      b = i.x,\n      k = i.y,\n      x = i.width,\n      A = i.height,\n      W = i.data,\n      O = i.direction,\n      z = void 0 === O ? \"left-to-right\" : O,\n      B = i.justify,\n      w = void 0 !== B && B,\n      X = i.textColor,\n      Y = i.background,\n      H = void 0 === Y ? \"transparent\" : Y,\n      E = i.opacity,\n      j = void 0 === E ? 1 : E,\n      T = i.symbolShape,\n      L = void 0 === T ? \"square\" : T,\n      M = i.symbolSize,\n      F = void 0 === M ? 16 : M,\n      P = i.symbolSpacing,\n      R = void 0 === P ? 8 : P,\n      q = i.symbolBorderWidth,\n      V = void 0 === q ? 0 : q,\n      D = i.symbolBorderColor,\n      G = void 0 === D ? \"transparent\" : D,\n      I = i.onClick,\n      N = i.onMouseEnter,\n      _ = i.onMouseLeave,\n      J = i.toggleSerie,\n      K = i.effects,\n      Q = s({}),\n      U = Q[0],\n      Z = Q[1],\n      $ = o(),\n      tt = d(function (t) {\n        if (K) {\n          var e = K.filter(function (t) {\n            return \"hover\" === t.on;\n          }).reduce(function (t, e) {\n            return p({}, t, e.style);\n          }, {});\n          Z(e);\n        }\n        null == N || N(W, t);\n      }, [N, W, K]),\n      et = d(function (t) {\n        if (K) {\n          var e = K.filter(function (t) {\n            return \"hover\" !== t.on;\n          }).reduce(function (t, e) {\n            return p({}, t, e.style);\n          }, {});\n          Z(e);\n        }\n        null == _ || _(W, t);\n      }, [_, W, K]),\n      it = S({\n        direction: z,\n        justify: w,\n        symbolSize: null != (n = U.symbolSize) ? n : F,\n        symbolSpacing: R,\n        width: x,\n        height: A\n      }),\n      nt = it.symbolX,\n      ot = it.symbolY,\n      rt = it.labelX,\n      lt = it.labelY,\n      at = it.labelAnchor,\n      ct = it.labelAlignment,\n      st = [I, N, _, J].some(function (t) {\n        return void 0 !== t;\n      }),\n      dt = \"function\" == typeof L ? L : C[L];\n    return e(\"g\", {\n      transform: \"translate(\" + b + \",\" + k + \")\",\n      style: {\n        opacity: null != (r = U.itemOpacity) ? r : j\n      },\n      children: [t(\"rect\", {\n        width: x,\n        height: A,\n        fill: null != (l = U.itemBackground) ? l : H,\n        style: {\n          cursor: st ? \"pointer\" : \"auto\"\n        },\n        onClick: function (t) {\n          null == I || I(W, t), null == J || J(W.id);\n        },\n        onMouseEnter: tt,\n        onMouseLeave: et\n      }), a.createElement(dt, p({\n        id: W.id,\n        x: nt,\n        y: ot,\n        size: null != (c = U.symbolSize) ? c : F,\n        fill: null != (h = null != (g = W.fill) ? g : W.color) ? h : \"black\",\n        borderWidth: null != (m = U.symbolBorderWidth) ? m : V,\n        borderColor: null != (f = U.symbolBorderColor) ? f : G\n      }, W.hidden ? $.legends.hidden.symbol : void 0)), t(\"text\", {\n        textAnchor: at,\n        style: p({}, $.legends.text, {\n          fill: null != (u = null != (v = null != (y = U.itemTextColor) ? y : X) ? v : $.legends.text.fill) ? u : \"black\",\n          dominantBaseline: ct,\n          pointerEvents: \"none\",\n          userSelect: \"none\"\n        }, W.hidden ? $.legends.hidden.text : void 0),\n        x: rt,\n        y: lt,\n        children: W.label\n      })]\n    });\n  },\n  w = function (e) {\n    var i = e.data,\n      n = e.x,\n      o = e.y,\n      r = e.direction,\n      l = e.padding,\n      a = void 0 === l ? 0 : l,\n      c = e.justify,\n      s = e.effects,\n      d = e.itemWidth,\n      h = e.itemHeight,\n      g = e.itemDirection,\n      m = void 0 === g ? \"left-to-right\" : g,\n      f = e.itemsSpacing,\n      u = void 0 === f ? 0 : f,\n      v = e.itemTextColor,\n      p = e.itemBackground,\n      y = void 0 === p ? \"transparent\" : p,\n      b = e.itemOpacity,\n      x = void 0 === b ? 1 : b,\n      S = e.symbolShape,\n      A = e.symbolSize,\n      W = e.symbolSpacing,\n      O = e.symbolBorderWidth,\n      z = e.symbolBorderColor,\n      C = e.onClick,\n      w = e.onMouseEnter,\n      X = e.onMouseLeave,\n      Y = e.toggleSerie,\n      H = k({\n        itemCount: i.length,\n        itemWidth: d,\n        itemHeight: h,\n        itemsSpacing: u,\n        direction: r,\n        padding: a\n      }).padding,\n      E = \"row\" === r ? d + u : 0,\n      j = \"column\" === r ? h + u : 0;\n    return t(\"g\", {\n      transform: \"translate(\" + n + \",\" + o + \")\",\n      children: i.map(function (e, i) {\n        return t(B, {\n          data: e,\n          x: i * E + H.left,\n          y: i * j + H.top,\n          width: d,\n          height: h,\n          direction: m,\n          justify: c,\n          effects: s,\n          textColor: v,\n          background: y,\n          opacity: x,\n          symbolShape: S,\n          symbolSize: A,\n          symbolSpacing: W,\n          symbolBorderWidth: O,\n          symbolBorderColor: z,\n          onClick: C,\n          onMouseEnter: w,\n          onMouseLeave: X,\n          toggleSerie: Y\n        }, i);\n      })\n    });\n  },\n  X = function (e) {\n    var i = e.data,\n      n = e.containerWidth,\n      o = e.containerHeight,\n      r = e.translateX,\n      l = void 0 === r ? 0 : r,\n      a = e.translateY,\n      c = void 0 === a ? 0 : a,\n      s = e.anchor,\n      d = e.direction,\n      h = e.padding,\n      g = void 0 === h ? 0 : h,\n      m = e.justify,\n      f = e.itemsSpacing,\n      u = void 0 === f ? 0 : f,\n      v = e.itemWidth,\n      p = e.itemHeight,\n      y = e.itemDirection,\n      b = e.itemTextColor,\n      S = e.itemBackground,\n      A = e.itemOpacity,\n      W = e.symbolShape,\n      O = e.symbolSize,\n      z = e.symbolSpacing,\n      C = e.symbolBorderWidth,\n      B = e.symbolBorderColor,\n      X = e.onClick,\n      Y = e.onMouseEnter,\n      H = e.onMouseLeave,\n      E = e.toggleSerie,\n      j = e.effects,\n      T = k({\n        itemCount: i.length,\n        itemsSpacing: u,\n        itemWidth: v,\n        itemHeight: p,\n        direction: d,\n        padding: g\n      }),\n      L = T.width,\n      M = T.height,\n      F = x({\n        anchor: s,\n        translateX: l,\n        translateY: c,\n        containerWidth: n,\n        containerHeight: o,\n        width: L,\n        height: M\n      }),\n      P = F.x,\n      R = F.y;\n    return t(w, {\n      data: i,\n      x: P,\n      y: R,\n      direction: d,\n      padding: g,\n      justify: m,\n      effects: j,\n      itemsSpacing: u,\n      itemWidth: v,\n      itemHeight: p,\n      itemDirection: y,\n      itemTextColor: b,\n      itemBackground: S,\n      itemOpacity: A,\n      symbolShape: W,\n      symbolSize: O,\n      symbolSpacing: z,\n      symbolBorderWidth: C,\n      symbolBorderColor: B,\n      onClick: X,\n      onMouseEnter: Y,\n      onMouseLeave: H,\n      toggleSerie: \"boolean\" == typeof E ? void 0 : E\n    });\n  },\n  Y = {\n    start: \"left\",\n    middle: \"center\",\n    end: \"right\"\n  },\n  H = function (t, e) {\n    var i = e.data,\n      n = e.containerWidth,\n      o = e.containerHeight,\n      r = e.translateX,\n      l = void 0 === r ? 0 : r,\n      a = e.translateY,\n      c = void 0 === a ? 0 : a,\n      s = e.anchor,\n      d = e.direction,\n      h = e.padding,\n      g = void 0 === h ? 0 : h,\n      m = e.justify,\n      f = void 0 !== m && m,\n      u = e.itemsSpacing,\n      v = void 0 === u ? 0 : u,\n      p = e.itemWidth,\n      y = e.itemHeight,\n      b = e.itemDirection,\n      A = void 0 === b ? \"left-to-right\" : b,\n      W = e.itemTextColor,\n      O = e.symbolSize,\n      z = void 0 === O ? 16 : O,\n      C = e.symbolSpacing,\n      B = void 0 === C ? 8 : C,\n      w = e.theme,\n      X = k({\n        itemCount: i.length,\n        itemWidth: p,\n        itemHeight: y,\n        itemsSpacing: v,\n        direction: d,\n        padding: g\n      }),\n      H = X.width,\n      E = X.height,\n      j = X.padding,\n      T = x({\n        anchor: s,\n        translateX: l,\n        translateY: c,\n        containerWidth: n,\n        containerHeight: o,\n        width: H,\n        height: E\n      }),\n      L = T.x,\n      M = T.y,\n      F = \"row\" === d ? p + v : 0,\n      P = \"column\" === d ? y + v : 0;\n    t.save(), t.translate(L, M), t.font = w.legends.text.fontSize + \"px \" + (w.legends.text.fontFamily || \"sans-serif\"), i.forEach(function (e, i) {\n      var n,\n        o,\n        r = i * F + j.left,\n        l = i * P + j.top,\n        a = S({\n          direction: A,\n          justify: f,\n          symbolSize: z,\n          symbolSpacing: B,\n          width: p,\n          height: y\n        }),\n        c = a.symbolX,\n        s = a.symbolY,\n        d = a.labelX,\n        h = a.labelY,\n        g = a.labelAnchor,\n        m = a.labelAlignment;\n      t.fillStyle = null != (n = e.color) ? n : \"black\", t.fillRect(r + c, l + s, z, z), t.textAlign = Y[g], \"central\" === m && (t.textBaseline = \"middle\"), t.fillStyle = null != (o = null != W ? W : w.legends.text.fill) ? o : \"black\", t.fillText(String(e.label), r + d, l + h);\n    }), t.restore();\n  },\n  E = function (t, e) {\n    var i = e.containerWidth,\n      n = e.containerHeight,\n      o = e.anchor,\n      l = e.translateX,\n      a = void 0 === l ? 0 : l,\n      c = e.translateY,\n      s = void 0 === c ? 0 : c,\n      d = e.scale,\n      h = e.length,\n      g = void 0 === h ? y.length : h,\n      m = e.thickness,\n      f = void 0 === m ? y.thickness : m,\n      u = e.direction,\n      v = void 0 === u ? y.direction : u,\n      p = e.ticks,\n      b = e.tickPosition,\n      k = void 0 === b ? y.tickPosition : b,\n      S = e.tickSize,\n      W = void 0 === S ? y.tickSize : S,\n      O = e.tickSpacing,\n      z = void 0 === O ? y.tickSpacing : O,\n      C = e.tickOverlap,\n      B = void 0 === C ? y.tickOverlap : C,\n      w = e.tickFormat,\n      X = void 0 === w ? y.tickFormat : w,\n      Y = e.title,\n      H = e.titleAlign,\n      E = void 0 === H ? y.titleAlign : H,\n      j = e.titleOffset,\n      T = void 0 === j ? y.titleOffset : j,\n      L = e.theme,\n      M = A({\n        scale: d,\n        ticks: p,\n        length: g,\n        thickness: f,\n        direction: v,\n        tickPosition: k,\n        tickSize: W,\n        tickSpacing: z,\n        tickOverlap: B,\n        tickFormat: X,\n        title: Y,\n        titleAlign: E,\n        titleOffset: T\n      }),\n      F = M.width,\n      P = M.height,\n      R = M.gradientX1,\n      q = M.gradientY1,\n      V = M.gradientX2,\n      D = M.gradientY2,\n      G = M.colorStops,\n      I = M.ticks,\n      N = M.titleText,\n      _ = M.titleX,\n      J = M.titleY,\n      K = M.titleRotation,\n      Q = M.titleVerticalAlign,\n      U = M.titleHorizontalAlign,\n      Z = x({\n        anchor: o,\n        translateX: a,\n        translateY: s,\n        containerWidth: i,\n        containerHeight: n,\n        width: F,\n        height: P\n      }),\n      $ = Z.x,\n      tt = Z.y,\n      et = {\n        font: t.font,\n        textAlign: t.textAlign,\n        textBaseline: t.textBaseline\n      };\n    t.save(), t.translate($, tt);\n    var it = t.createLinearGradient(R * F, q * P, V * F, D * P);\n    G.forEach(function (t) {\n      it.addColorStop(t.offset, t.stopColor);\n    }), t.fillStyle = it, t.fillRect(0, 0, F, P), t.font = (L.legends.ticks.text.fontWeight ? L.legends.ticks.text.fontWeight + \" \" : \"\") + L.legends.ticks.text.fontSize + \"px \" + L.legends.ticks.text.fontFamily, I.forEach(function (e) {\n      var i;\n      (null != (i = L.legends.ticks.line.strokeWidth) ? i : 0) > 0 && (t.lineWidth = Number(L.axis.ticks.line.strokeWidth), L.axis.ticks.line.stroke && (t.strokeStyle = L.axis.ticks.line.stroke), t.lineCap = \"square\", t.beginPath(), t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.stroke()), L.legends.ticks.text.fill && (t.fillStyle = L.legends.ticks.text.fill), t.textAlign = \"middle\" === e.textHorizontalAlign ? \"center\" : e.textHorizontalAlign, t.textBaseline = \"central\" === e.textVerticalAlign ? \"middle\" : e.textVerticalAlign, t.fillText(e.text, e.textX, e.textY);\n    }), N && (t.save(), t.translate(_, J), t.rotate(r(K)), t.font = (L.legends.title.text.fontWeight ? L.legends.title.text.fontWeight + \" \" : \"\") + L.legends.title.text.fontSize + \"px \" + L.legends.title.text.fontFamily, L.legends.title.text.fill && (t.fillStyle = L.legends.title.text.fill), t.textAlign = \"middle\" === U ? \"center\" : U, t.textBaseline = Q, t.fillText(N, 0, 0), t.restore()), t.restore(), t.font = et.font, t.textAlign = et.textAlign, t.textBaseline = et.textBaseline;\n  },\n  j = function (t) {\n    var e = t.scale,\n      i = t.domain,\n      n = t.reverse,\n      o = void 0 !== n && n,\n      r = t.valueFormat,\n      l = void 0 === r ? function (t) {\n        return t;\n      } : r,\n      a = t.separator,\n      c = void 0 === a ? \" - \" : a;\n    return h(function () {\n      var t = (null != i ? i : e.range()).map(function (t, i) {\n        var n = e.invertExtent(t),\n          o = n[0],\n          r = n[1];\n        return {\n          id: t,\n          index: i,\n          extent: [o, r],\n          label: \"\" + l(o) + c + l(r),\n          value: e(o),\n          color: t\n        };\n      });\n      return o && t.reverse(), t;\n    }, [i, e, o, c, l]);\n  },\n  T = {\n    data: g.arrayOf(g.object),\n    anchor: g.oneOf([\"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\", \"top-left\", \"center\"]).isRequired,\n    translateX: g.number,\n    translateY: g.number,\n    direction: g.oneOf([\"row\", \"column\"]).isRequired,\n    itemsSpacing: g.number,\n    itemWidth: g.number.isRequired,\n    itemHeight: g.number.isRequired,\n    itemDirection: g.oneOf([\"left-to-right\", \"right-to-left\", \"top-to-bottom\", \"bottom-to-top\"]),\n    itemTextColor: g.string,\n    itemBackground: g.string,\n    itemOpacity: g.number,\n    symbolShape: g.oneOfType([g.oneOf([\"circle\", \"diamond\", \"square\", \"triangle\"]), g.func]),\n    symbolSize: g.number,\n    symbolSpacing: g.number,\n    symbolBorderWidth: g.number,\n    symbolBorderColor: g.string,\n    onClick: g.func,\n    onMouseEnter: g.func,\n    onMouseLeave: g.func,\n    effects: g.arrayOf(g.shape({\n      on: g.oneOfType([g.oneOf([\"hover\"])]).isRequired,\n      style: g.shape({\n        itemTextColor: g.string,\n        itemBackground: g.string,\n        itemOpacity: g.number,\n        symbolSize: g.number,\n        symbolBorderWidth: g.number,\n        symbolBorderColor: g.string\n      }).isRequired\n    }))\n  };\nexport { z as AnchoredContinuousColorsLegendSvg, X as BoxLegendSvg, W as ContinuousColorsLegendSvg, T as LegendPropShape, w as LegendSvg, B as LegendSvgItem, m as SymbolCircle, f as SymbolDiamond, u as SymbolSquare, v as SymbolTriangle, A as computeContinuousColorsLegend, k as computeDimensions, S as computeItemLayout, x as computePositionFromAnchor, y as continuousColorsLegendDefaults, E as renderContinuousColorLegendToCanvas, H as renderLegendToCanvas, j as useQuantizeColorScaleLegendData };","map":{"version":3,"names":["m","SymbolCircle","e","i","x","n","y","o","size","r","fill","l","opacity","a","c","borderWidth","s","d","borderColor","t","cx","cy","strokeWidth","stroke","style","pointerEvents","f","SymbolDiamond","transform","children","u","SymbolSquare","width","height","v","SymbolTriangle","p","Object","assign","bind","arguments","length","prototype","hasOwnProperty","call","apply","thickness","direction","tickPosition","tickSize","tickSpacing","tickOverlap","tickFormat","titleAlign","titleOffset","b","top","right","bottom","left","k","computeDimensions","itemsSpacing","padding","itemCount","itemWidth","itemHeight","Array","isArray","Error","h","g","computePositionFromAnchor","anchor","translateX","translateY","containerWidth","containerHeight","S","computeItemLayout","justify","symbolSize","symbolSpacing","symbolX","symbolY","labelX","labelY","labelAnchor","labelAlignment","A","computeContinuousColorsLegend","scale","ticks","W","title","O","z","C","B","w","concat","domain","reverse","X","range","thresholds","Y","H","E","j","T","L","M","F","P","R","q","V","D","G","I","forEach","push","x1","y1","x2","y2","text","textX","textY","textHorizontalAlign","textVerticalAlign","N","_","J","K","gradientX1","gradientY1","gradientX2","gradientY2","colorStops","titleText","titleX","titleY","titleRotation","titleHorizontalAlign","titleVerticalAlign","ContinuousColorsLegendSvg","map","offset","join","id","textAnchor","dominantBaseline","legends","line","AnchoredContinuousColorsLegendSvg","keys","indexOf","circle","diamond","square","triangle","LegendSvgItem","data","textColor","background","symbolShape","symbolBorderWidth","symbolBorderColor","onClick","onMouseEnter","onMouseLeave","toggleSerie","effects","Q","U","Z","$","tt","filter","on","reduce","et","it","nt","ot","rt","lt","at","ct","st","some","dt","itemOpacity","itemBackground","cursor","createElement","color","hidden","symbol","itemTextColor","userSelect","label","LegendSvg","itemDirection","BoxLegendSvg","start","middle","end","renderLegendToCanvas","theme","save","translate","font","fontSize","fontFamily","fillStyle","fillRect","textAlign","textBaseline","fillText","String","restore","renderContinuousColorLegendToCanvas","createLinearGradient","addColorStop","stopColor","fontWeight","lineWidth","Number","axis","strokeStyle","lineCap","beginPath","moveTo","lineTo","rotate","useQuantizeColorScaleLegendData","valueFormat","separator","invertExtent","index","extent","value","arrayOf","object","oneOf","isRequired","number","string","oneOfType","func","shape","LegendPropShape","continuousColorsLegendDefaults"],"sources":["C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\symbols\\SymbolCircle.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\symbols\\SymbolDiamond.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\symbols\\SymbolSquare.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\symbols\\SymbolTriangle.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\defaults.ts","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\compute.ts","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\ContinuousColorsLegendSvg.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\AnchoredContinuousColorsLegendSvg.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\LegendSvgItem.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\LegendSvg.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\svg\\BoxLegendSvg.tsx","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\canvas.ts","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\hooks.ts","C:\\Users\\Caio\\Documents\\GeauxFrontend\\wsb-analytics\\client\\node_modules\\@nivo\\legends\\src\\props.ts"],"sourcesContent":["import { SymbolProps } from './types'\n\nexport const SymbolCircle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <circle\n            r={size / 2}\n            cx={x + size / 2}\n            cy={y + size / 2}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolDiamond = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                    M${size / 2} 0\n                    L${size * 0.8} ${size / 2}\n                    L${size / 2} ${size}\n                    L${size * 0.2} ${size / 2}\n                    L${size / 2} 0\n                `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolSquare = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <rect\n            x={x}\n            y={y}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            width={size}\n            height={size}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolTriangle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                M${size / 2} 0\n                L${size} ${size}\n                L0 ${size}\n                L${size / 2} 0\n            `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n","import { ContinuousColorsLegendProps } from './types'\n\nexport const continuousColorsLegendDefaults: {\n    length: NonNullable<ContinuousColorsLegendProps['length']>\n    thickness: NonNullable<ContinuousColorsLegendProps['thickness']>\n    direction: NonNullable<ContinuousColorsLegendProps['direction']>\n    tickPosition: NonNullable<ContinuousColorsLegendProps['tickPosition']>\n    tickSize: NonNullable<ContinuousColorsLegendProps['tickSize']>\n    tickSpacing: NonNullable<ContinuousColorsLegendProps['tickSpacing']>\n    tickOverlap: NonNullable<ContinuousColorsLegendProps['tickOverlap']>\n    tickFormat: NonNullable<ContinuousColorsLegendProps['tickFormat']>\n    titleAlign: NonNullable<ContinuousColorsLegendProps['titleAlign']>\n    titleOffset: NonNullable<ContinuousColorsLegendProps['titleOffset']>\n} = {\n    length: 200,\n    thickness: 16,\n    direction: 'row',\n    tickPosition: 'after',\n    tickSize: 4,\n    tickSpacing: 3,\n    tickOverlap: false,\n    tickFormat: (value: number) => `${value}`,\n    titleAlign: 'start',\n    titleOffset: 4,\n}\n","import { scaleLinear } from 'd3-scale'\nimport { getValueFormatter } from '@nivo/core'\nimport { computeContinuousColorScaleColorStops } from '@nivo/colors'\nimport {\n    BoxLegendSvgProps,\n    ContinuousColorsLegendProps,\n    LegendAnchor,\n    LegendItemDirection,\n} from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst isObject = <T>(item: unknown): item is T =>\n    typeof item === 'object' && !Array.isArray(item) && item !== null\n\nconst zeroPadding = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n}\n\nexport const computeDimensions = ({\n    direction,\n    itemsSpacing,\n    padding: _padding,\n    itemCount,\n    itemWidth,\n    itemHeight,\n}: Pick<BoxLegendSvgProps, 'direction' | 'padding'> &\n    Record<'itemsSpacing' | 'itemCount' | 'itemWidth' | 'itemHeight', number>) => {\n    if (typeof _padding !== 'number' && !isObject(_padding)) {\n        throw new Error('Invalid property padding, must be one of: number, object')\n    }\n\n    const padding =\n        typeof _padding === 'number'\n            ? {\n                  top: _padding,\n                  right: _padding,\n                  bottom: _padding,\n                  left: _padding,\n              }\n            : {\n                  ...zeroPadding,\n                  ..._padding,\n              }\n\n    const horizontalPadding = padding.left + padding.right\n    const verticalPadding = padding.top + padding.bottom\n    let width = itemWidth + horizontalPadding\n    let height = itemHeight + verticalPadding\n    const spacing = (itemCount - 1) * itemsSpacing\n    if (direction === 'row') {\n        width = itemWidth * itemCount + spacing + horizontalPadding\n    } else if (direction === 'column') {\n        height = itemHeight * itemCount + spacing + verticalPadding\n    }\n\n    return { width, height, padding }\n}\n\nexport const computePositionFromAnchor = ({\n    anchor,\n    translateX,\n    translateY,\n    containerWidth,\n    containerHeight,\n    width,\n    height,\n}: { anchor: LegendAnchor } & Record<\n    'translateX' | 'translateY' | 'containerWidth' | 'containerHeight' | 'width' | 'height',\n    number\n>) => {\n    let x = translateX\n    let y = translateY\n\n    switch (anchor) {\n        case 'top':\n            x += (containerWidth - width) / 2\n            break\n\n        case 'top-right':\n            x += containerWidth - width\n            break\n\n        case 'right':\n            x += containerWidth - width\n            y += (containerHeight - height) / 2\n            break\n\n        case 'bottom-right':\n            x += containerWidth - width\n            y += containerHeight - height\n            break\n\n        case 'bottom':\n            x += (containerWidth - width) / 2\n            y += containerHeight - height\n            break\n\n        case 'bottom-left':\n            y += containerHeight - height\n            break\n\n        case 'left':\n            y += (containerHeight - height) / 2\n            break\n\n        case 'center':\n            x += (containerWidth - width) / 2\n            y += (containerHeight - height) / 2\n            break\n    }\n\n    return { x, y }\n}\n\nexport const computeItemLayout = ({\n    direction,\n    justify,\n    symbolSize,\n    symbolSpacing,\n    width,\n    height,\n}: {\n    direction: LegendItemDirection\n    justify: boolean\n} & Record<'symbolSize' | 'symbolSpacing' | 'width' | 'height', number>) => {\n    let symbolX\n    let symbolY\n\n    let labelX\n    let labelY\n    let labelAnchor: 'start' | 'middle' | 'end'\n    let labelAlignment: 'alphabetic' | 'central' | 'text-before-edge'\n\n    switch (direction) {\n        case 'left-to-right':\n            symbolX = 0\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = width\n                labelAnchor = 'end'\n            } else {\n                labelX = symbolSize + symbolSpacing\n                labelAnchor = 'start'\n            }\n            break\n\n        case 'right-to-left':\n            symbolX = width - symbolSize\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = 0\n                labelAnchor = 'start'\n            } else {\n                labelX = width - symbolSize - symbolSpacing\n                labelAnchor = 'end'\n            }\n            break\n\n        case 'top-to-bottom':\n            symbolX = (width - symbolSize) / 2\n            symbolY = 0\n\n            labelX = width / 2\n\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = height\n                labelAlignment = 'alphabetic'\n            } else {\n                labelY = symbolSize + symbolSpacing\n                labelAlignment = 'text-before-edge'\n            }\n            break\n\n        case 'bottom-to-top':\n            symbolX = (width - symbolSize) / 2\n            symbolY = height - symbolSize\n\n            labelX = width / 2\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = 0\n                labelAlignment = 'text-before-edge'\n            } else {\n                labelY = height - symbolSize - symbolSpacing\n                labelAlignment = 'alphabetic'\n            }\n            break\n    }\n\n    return {\n        symbolX,\n        symbolY,\n        labelX,\n        labelY,\n        labelAnchor,\n        labelAlignment,\n    }\n}\n\nexport const computeContinuousColorsLegend = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    // left to right for `row`, bottom to top for `column`\n    const domain = direction === 'column' ? [...scale.domain()].reverse() : scale.domain()\n\n    const positionScale = scaleLinear().domain(domain)\n    if (domain.length === 2) {\n        // sequential, quantize\n        positionScale.range([0, length])\n    } else if (domain.length === 3) {\n        // diverging\n        positionScale.range([0, length / 2, length])\n    }\n\n    let values: number[]\n    if ('thresholds' in scale) {\n        // quantize\n        values = [domain[0], ...scale.thresholds(), domain[1]]\n    } else {\n        // sequential, diverging\n        values = Array.isArray(ticks) ? ticks : (scale as any).ticks(ticks)\n    }\n\n    const colorStops = computeContinuousColorScaleColorStops(scale, 32)\n\n    const formatValue = getValueFormatter(tickFormat)\n\n    const computedTicks: {\n        x1: number\n        y1: number\n        x2: number\n        y2: number\n        text: string\n        textX: number\n        textY: number\n        textHorizontalAlign: 'start' | 'middle' | 'end'\n        textVerticalAlign: 'alphabetic' | 'central' | 'hanging'\n    }[] = []\n\n    let width: number\n    let height: number\n\n    const gradientX1 = 0\n    let gradientY1 = 0\n    let gradientX2 = 0\n    const gradientY2 = 0\n\n    let titleX: number\n    let titleY: number\n    let titleRotation: number\n    let titleVerticalAlign: 'alphabetic' | 'hanging'\n\n    if (direction === 'row') {\n        width = length\n        height = thickness\n\n        gradientX2 = 1\n\n        let y1: number\n        let y2: number\n\n        let textY: number\n        const textHorizontalAlign = 'middle'\n        let textVerticalAlign: 'alphabetic' | 'hanging'\n\n        titleRotation = 0\n        if (titleAlign === 'start') {\n            titleX = 0\n        } else if (titleAlign === 'middle') {\n            titleX = length / 2\n        } else {\n            titleX = length\n        }\n\n        if (tickPosition === 'before') {\n            y1 = -tickSize\n            y2 = tickOverlap ? thickness : 0\n\n            textY = -tickSize - tickSpacing\n            textVerticalAlign = 'alphabetic'\n\n            titleY = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            y1 = tickOverlap ? 0 : thickness\n            y2 = thickness + tickSize\n\n            textY = y2 + tickSpacing\n            textVerticalAlign = 'hanging'\n\n            titleY = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const x = positionScale(value)\n\n            computedTicks.push({\n                x1: x,\n                y1,\n                x2: x,\n                y2,\n                text: formatValue(value),\n                textX: x,\n                textY,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    } else {\n        width = thickness\n        height = length\n\n        gradientY1 = 1\n\n        let x1: number\n        let x2: number\n\n        let textX: number\n        let textHorizontalAlign: 'start' | 'end'\n        const textVerticalAlign = 'central'\n\n        titleRotation = -90\n        if (titleAlign === 'start') {\n            titleY = length\n        } else if (titleAlign === 'middle') {\n            titleY = length / 2\n        } else {\n            titleY = 0\n        }\n\n        if (tickPosition === 'before') {\n            x1 = -tickSize\n            x2 = tickOverlap ? thickness : 0\n\n            textX = x1 - tickSpacing\n            textHorizontalAlign = 'end'\n\n            titleX = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            x1 = tickOverlap ? 0 : thickness\n            x2 = thickness + tickSize\n\n            textX = x2 + tickSpacing\n            textHorizontalAlign = 'start'\n\n            titleX = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const y = positionScale(value)\n\n            computedTicks.push({\n                x1,\n                y1: y,\n                x2,\n                y2: y,\n                text: formatValue(value),\n                textX,\n                textY: y,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    }\n\n    return {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks: computedTicks,\n        titleText: title,\n        titleX,\n        titleY,\n        titleRotation,\n        titleHorizontalAlign: titleAlign,\n        titleVerticalAlign,\n    }\n}\n","import { Fragment } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { computeContinuousColorsLegend } from '../compute'\nimport { ContinuousColorsLegendProps } from '../types'\nimport { continuousColorsLegendDefaults } from '../defaults'\n\nexport const ContinuousColorsLegendSvg = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        ticks: computedTicks,\n        colorStops,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const theme = useTheme()\n\n    const id = `ContinuousColorsLegendSvgGradient.${direction}.${colorStops\n        .map(stop => stop.offset)\n        .join('_')}`\n\n    return (\n        <g>\n            <defs>\n                <linearGradient\n                    id={id}\n                    x1={gradientX1}\n                    y1={gradientY1}\n                    x2={gradientX2}\n                    y2={gradientY2}\n                >\n                    {colorStops.map(colorStop => (\n                        <stop {...colorStop} />\n                    ))}\n                </linearGradient>\n            </defs>\n            {titleText && (\n                <text\n                    transform={`translate(${titleX}, ${titleY}) rotate(${titleRotation})`}\n                    textAnchor={titleHorizontalAlign}\n                    dominantBaseline={titleVerticalAlign}\n                    style={theme.legends.title.text}\n                >\n                    {titleText}\n                </text>\n            )}\n            <rect width={width} height={height} fill={`url(#${id}`} />\n            {computedTicks.map((tick, index) => (\n                <Fragment key={index}>\n                    <line\n                        x1={tick.x1}\n                        y1={tick.y1}\n                        x2={tick.x2}\n                        y2={tick.y2}\n                        style={theme.legends.ticks.line}\n                    />\n                    <text\n                        x={tick.textX}\n                        y={tick.textY}\n                        textAnchor={tick.textHorizontalAlign}\n                        dominantBaseline={tick.textVerticalAlign}\n                        style={theme.legends.ticks.text}\n                    >\n                        {tick.text}\n                    </text>\n                </Fragment>\n            ))}\n        </g>\n    )\n}\n","import { AnchoredContinuousColorsLegendProps } from '../types'\nimport { computePositionFromAnchor } from '../compute'\nimport { continuousColorsLegendDefaults } from '../defaults'\nimport { ContinuousColorsLegendSvg } from './ContinuousColorsLegendSvg'\n\nexport const AnchoredContinuousColorsLegendSvg = ({\n    containerWidth,\n    containerHeight,\n    anchor,\n    translateX = 0,\n    translateY = 0,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    ...legendProps\n}: AnchoredContinuousColorsLegendProps) => {\n    let width: number\n    let height: number\n    if (direction === 'row') {\n        width = length\n        height = thickness\n    } else {\n        width = thickness\n        height = length\n    }\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <g transform={`translate(${x}, ${y})`}>\n            <ContinuousColorsLegendSvg\n                length={length}\n                thickness={thickness}\n                direction={direction}\n                {...legendProps}\n            />\n        </g>\n    )\n}\n","import { useState, useCallback } from 'react'\nimport * as React from 'react'\nimport { useTheme } from '@nivo/core'\nimport { LegendSvgItemProps } from '../types'\nimport { computeItemLayout } from '../compute'\nimport { SymbolCircle, SymbolDiamond, SymbolSquare, SymbolTriangle } from './symbols'\n\ntype Style = Partial<{\n    itemBackground: string\n    itemOpacity: number\n    itemTextColor: string\n    symbolBorderColor: string\n    symbolBorderWidth: number\n    symbolSize: number\n}>\n\nconst symbolByShape = {\n    circle: SymbolCircle,\n    diamond: SymbolDiamond,\n    square: SymbolSquare,\n    triangle: SymbolTriangle,\n}\n\nexport const LegendSvgItem = ({\n    x,\n    y,\n    width,\n    height,\n    data,\n    direction = 'left-to-right',\n    justify = false,\n    textColor,\n    background = 'transparent',\n    opacity = 1,\n\n    symbolShape = 'square',\n    symbolSize = 16,\n    symbolSpacing = 8,\n    symbolBorderWidth = 0,\n    symbolBorderColor = 'transparent',\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n\n    effects,\n}: LegendSvgItemProps) => {\n    const [style, setStyle] = useState<Style>({})\n    const theme = useTheme()\n\n    const handleMouseEnter = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on === 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseEnter?.(data, event)\n        },\n        [onMouseEnter, data, effects]\n    )\n    const handleMouseLeave = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on !== 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseLeave?.(data, event)\n        },\n        [onMouseLeave, data, effects]\n    )\n\n    const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout({\n        direction,\n        justify,\n        symbolSize: style.symbolSize ?? symbolSize,\n        symbolSpacing,\n        width,\n        height,\n    })\n\n    const isInteractive = [onClick, onMouseEnter, onMouseLeave, toggleSerie].some(\n        handler => handler !== undefined\n    )\n\n    const SymbolShape = typeof symbolShape === 'function' ? symbolShape : symbolByShape[symbolShape]\n\n    return (\n        <g\n            transform={`translate(${x},${y})`}\n            style={{\n                opacity: style.itemOpacity ?? opacity,\n            }}\n        >\n            <rect\n                width={width}\n                height={height}\n                fill={style.itemBackground ?? background}\n                style={{\n                    cursor: isInteractive ? 'pointer' : 'auto',\n                }}\n                onClick={event => {\n                    onClick?.(data, event)\n                    toggleSerie?.(data.id)\n                }}\n                onMouseEnter={handleMouseEnter}\n                onMouseLeave={handleMouseLeave}\n            />\n            {React.createElement(SymbolShape, {\n                id: data.id,\n                x: symbolX,\n                y: symbolY,\n                size: style.symbolSize ?? symbolSize,\n                fill: data.fill ?? data.color ?? 'black',\n                borderWidth: style.symbolBorderWidth ?? symbolBorderWidth,\n                borderColor: style.symbolBorderColor ?? symbolBorderColor,\n                ...(data.hidden ? theme.legends.hidden.symbol : undefined),\n            })}\n            <text\n                textAnchor={labelAnchor}\n                style={{\n                    ...theme.legends.text,\n                    fill: style.itemTextColor ?? textColor ?? theme.legends.text.fill ?? 'black',\n                    dominantBaseline: labelAlignment,\n                    pointerEvents: 'none',\n                    userSelect: 'none',\n                    ...(data.hidden ? theme.legends.hidden.text : undefined),\n                }}\n                x={labelX}\n                y={labelY}\n            >\n                {data.label}\n            </text>\n        </g>\n    )\n}\n","import { LegendSvgItem } from './LegendSvgItem'\nimport { LegendSvgProps } from '../types'\nimport { computeDimensions } from '../compute'\n\nexport const LegendSvg = ({\n    data,\n\n    x,\n    y,\n    direction,\n    padding: _padding = 0,\n    justify,\n    effects,\n\n    itemWidth,\n    itemHeight,\n    itemDirection = 'left-to-right',\n    itemsSpacing = 0,\n    itemTextColor,\n    itemBackground = 'transparent',\n    itemOpacity = 1,\n\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n}: LegendSvgProps) => {\n    const { padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    return (\n        <g transform={`translate(${x},${y})`}>\n            {data.map((data, i) => (\n                <LegendSvgItem\n                    key={i}\n                    data={data}\n                    x={i * xStep + padding.left}\n                    y={i * yStep + padding.top}\n                    width={itemWidth}\n                    height={itemHeight}\n                    direction={itemDirection}\n                    justify={justify}\n                    effects={effects}\n                    textColor={itemTextColor}\n                    background={itemBackground}\n                    opacity={itemOpacity}\n                    symbolShape={symbolShape}\n                    symbolSize={symbolSize}\n                    symbolSpacing={symbolSpacing}\n                    symbolBorderWidth={symbolBorderWidth}\n                    symbolBorderColor={symbolBorderColor}\n                    onClick={onClick}\n                    onMouseEnter={onMouseEnter}\n                    onMouseLeave={onMouseLeave}\n                    toggleSerie={toggleSerie}\n                />\n            ))}\n        </g>\n    )\n}\n","import { LegendSvg } from './LegendSvg'\nimport { BoxLegendSvgProps } from '../types'\nimport { computeDimensions, computePositionFromAnchor } from '../compute'\n\nexport const BoxLegendSvg = ({\n    data,\n\n    containerWidth,\n    containerHeight,\n    translateX = 0,\n    translateY = 0,\n    anchor,\n    direction,\n    padding = 0,\n    justify,\n\n    itemsSpacing = 0,\n    itemWidth,\n    itemHeight,\n    itemDirection,\n    itemTextColor,\n    itemBackground,\n    itemOpacity,\n\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n\n    effects,\n}: BoxLegendSvgProps) => {\n    const { width, height } = computeDimensions({\n        itemCount: data.length,\n        itemsSpacing,\n        itemWidth,\n        itemHeight,\n        direction,\n        padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <LegendSvg\n            data={data}\n            x={x}\n            y={y}\n            direction={direction}\n            padding={padding}\n            justify={justify}\n            effects={effects}\n            itemsSpacing={itemsSpacing}\n            itemWidth={itemWidth}\n            itemHeight={itemHeight}\n            itemDirection={itemDirection}\n            itemTextColor={itemTextColor}\n            itemBackground={itemBackground}\n            itemOpacity={itemOpacity}\n            symbolShape={symbolShape}\n            symbolSize={symbolSize}\n            symbolSpacing={symbolSpacing}\n            symbolBorderWidth={symbolBorderWidth}\n            symbolBorderColor={symbolBorderColor}\n            onClick={onClick}\n            onMouseEnter={onMouseEnter}\n            onMouseLeave={onMouseLeave}\n            toggleSerie={typeof toggleSerie === 'boolean' ? undefined : toggleSerie}\n        />\n    )\n}\n","import { CompleteTheme, degreesToRadians } from '@nivo/core'\nimport {\n    computeDimensions,\n    computePositionFromAnchor,\n    computeItemLayout,\n    computeContinuousColorsLegend,\n} from './compute'\nimport { AnchoredContinuousColorsLegendProps, LegendCanvasProps } from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst textAlignMapping = {\n    start: 'left',\n    middle: 'center',\n    end: 'right',\n} as const\n\nexport const renderLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        data,\n\n        containerWidth,\n        containerHeight,\n        translateX = 0,\n        translateY = 0,\n        anchor,\n        direction,\n        padding: _padding = 0,\n        justify = false,\n\n        // items\n        itemsSpacing = 0,\n        itemWidth,\n        itemHeight,\n        itemDirection = 'left-to-right',\n        itemTextColor,\n\n        // symbol\n        symbolSize = 16,\n        symbolSpacing = 8,\n        // @todo add support for shapes\n        // symbolShape = LegendSvgItem.defaultProps.symbolShape,\n\n        theme,\n    }: LegendCanvasProps\n) => {\n    const { width, height, padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.font = `${theme.legends.text.fontSize}px ${theme.legends.text.fontFamily || 'sans-serif'}`\n\n    data.forEach((d, i) => {\n        const itemX = i * xStep + padding.left\n        const itemY = i * yStep + padding.top\n\n        const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout(\n            {\n                direction: itemDirection,\n                justify,\n                symbolSize,\n                symbolSpacing,\n                width: itemWidth,\n                height: itemHeight,\n            }\n        )\n\n        ctx.fillStyle = d.color ?? 'black'\n        ctx.fillRect(itemX + symbolX, itemY + symbolY, symbolSize, symbolSize)\n\n        ctx.textAlign = textAlignMapping[labelAnchor]\n\n        if (labelAlignment === 'central') {\n            ctx.textBaseline = 'middle'\n        }\n\n        ctx.fillStyle = itemTextColor ?? theme.legends.text.fill ?? 'black'\n        ctx.fillText(String(d.label), itemX + labelX, itemY + labelY)\n    })\n\n    ctx.restore()\n}\n\nexport const renderContinuousColorLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        containerWidth,\n        containerHeight,\n        anchor,\n        translateX = 0,\n        translateY = 0,\n        scale,\n        length = continuousColorsLegendDefaults.length,\n        thickness = continuousColorsLegendDefaults.thickness,\n        direction = continuousColorsLegendDefaults.direction,\n        ticks: _ticks,\n        tickPosition = continuousColorsLegendDefaults.tickPosition,\n        tickSize = continuousColorsLegendDefaults.tickSize,\n        tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n        tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n        tickFormat = continuousColorsLegendDefaults.tickFormat,\n        title,\n        titleAlign = continuousColorsLegendDefaults.titleAlign,\n        titleOffset = continuousColorsLegendDefaults.titleOffset,\n        theme,\n    }: AnchoredContinuousColorsLegendProps & {\n        theme: CompleteTheme\n    }\n) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks: _ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const initialStyles = {\n        font: ctx.font,\n        textAlign: ctx.textAlign,\n        textBaseline: ctx.textBaseline,\n    }\n    ctx.save()\n\n    ctx.translate(x, y)\n\n    const gradient = ctx.createLinearGradient(\n        gradientX1 * width,\n        gradientY1 * height,\n        gradientX2 * width,\n        gradientY2 * height\n    )\n    colorStops.forEach(colorStop => {\n        gradient.addColorStop(colorStop.offset, colorStop.stopColor)\n    })\n\n    ctx.fillStyle = gradient\n    ctx.fillRect(0, 0, width, height)\n\n    ctx.font = `${\n        theme.legends.ticks.text.fontWeight ? `${theme.legends.ticks.text.fontWeight} ` : ''\n    }${theme.legends.ticks.text.fontSize}px ${theme.legends.ticks.text.fontFamily}`\n\n    ticks.forEach(tick => {\n        if ((theme.legends.ticks.line.strokeWidth ?? 0) > 0) {\n            ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth)\n            if (theme.axis.ticks.line.stroke) {\n                ctx.strokeStyle = theme.axis.ticks.line.stroke\n            }\n            ctx.lineCap = 'square'\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x1, tick.y1)\n            ctx.lineTo(tick.x2, tick.y2)\n            ctx.stroke()\n        }\n\n        if (theme.legends.ticks.text.fill) {\n            ctx.fillStyle = theme.legends.ticks.text.fill\n        }\n        ctx.textAlign = tick.textHorizontalAlign === 'middle' ? 'center' : tick.textHorizontalAlign\n        ctx.textBaseline = tick.textVerticalAlign === 'central' ? 'middle' : tick.textVerticalAlign\n\n        ctx.fillText(tick.text, tick.textX, tick.textY)\n    })\n\n    if (titleText) {\n        ctx.save()\n        ctx.translate(titleX, titleY)\n        ctx.rotate(degreesToRadians(titleRotation))\n\n        ctx.font = `${\n            theme.legends.title.text.fontWeight ? `${theme.legends.title.text.fontWeight} ` : ''\n        }${theme.legends.title.text.fontSize}px ${theme.legends.title.text.fontFamily}`\n        if (theme.legends.title.text.fill) {\n            ctx.fillStyle = theme.legends.title.text.fill\n        }\n        ctx.textAlign = titleHorizontalAlign === 'middle' ? 'center' : titleHorizontalAlign\n        ctx.textBaseline = titleVerticalAlign\n\n        ctx.fillText(titleText, 0, 0)\n\n        ctx.restore()\n    }\n\n    ctx.restore()\n\n    ctx.font = initialStyles.font\n    ctx.textAlign = initialStyles.textAlign\n    ctx.textBaseline = initialStyles.textBaseline\n}\n","import { useMemo } from 'react'\n\ntype Scale = {\n    (value: number): number\n    invertExtent: (value: number) => [number, number]\n    range: () => number[]\n}\n\nexport const useQuantizeColorScaleLegendData = ({\n    scale,\n    domain: overriddenDomain,\n    reverse = false,\n    valueFormat = v => v,\n    separator = ' - ',\n}: {\n    scale: Scale\n    domain?: number[]\n    reverse?: boolean\n    valueFormat?: <T, U>(value: T) => T | U\n    separator?: string\n}) => {\n    return useMemo(() => {\n        const domain = overriddenDomain ?? scale.range()\n\n        const items = domain.map((domainValue, index) => {\n            const [start, end] = scale.invertExtent(domainValue)\n\n            return {\n                id: domainValue,\n                index,\n                extent: [start, end],\n                label: `${valueFormat(start)}${separator}${valueFormat(end)}`,\n                value: scale(start),\n                color: domainValue,\n            }\n        })\n\n        if (reverse) items.reverse()\n\n        return items\n    }, [overriddenDomain, scale, reverse, separator, valueFormat])\n}\n","import PropTypes from 'prop-types'\n\n/**\n * The prop type is exported as a simple object instead of `PropTypes.shape`\n * to be able to add extra properties.\n *\n * @example\n * ```javascript\n * import { LegendPropShape } from '@nivo/legends'\n *\n * const customLegendPropType = PropTypes.shape({\n *     ...LegendPropShape,\n *     extra: PropTypes.any.isRequired,\n * })\n * ```\n */\nexport const LegendPropShape = {\n    data: PropTypes.arrayOf(PropTypes.object),\n\n    // position & layout\n    anchor: PropTypes.oneOf([\n        'top',\n        'top-right',\n        'right',\n        'bottom-right',\n        'bottom',\n        'bottom-left',\n        'left',\n        'top-left',\n        'center',\n    ]).isRequired,\n    translateX: PropTypes.number,\n    translateY: PropTypes.number,\n    direction: PropTypes.oneOf(['row', 'column']).isRequired,\n\n    // item\n    itemsSpacing: PropTypes.number,\n    itemWidth: PropTypes.number.isRequired,\n    itemHeight: PropTypes.number.isRequired,\n    itemDirection: PropTypes.oneOf([\n        'left-to-right',\n        'right-to-left',\n        'top-to-bottom',\n        'bottom-to-top',\n    ]),\n    itemTextColor: PropTypes.string,\n    itemBackground: PropTypes.string,\n    itemOpacity: PropTypes.number,\n\n    symbolShape: PropTypes.oneOfType([\n        PropTypes.oneOf(['circle', 'diamond', 'square', 'triangle']),\n        PropTypes.func,\n    ]),\n    symbolSize: PropTypes.number,\n    symbolSpacing: PropTypes.number,\n    symbolBorderWidth: PropTypes.number,\n    symbolBorderColor: PropTypes.string,\n\n    onClick: PropTypes.func,\n    onMouseEnter: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n\n    effects: PropTypes.arrayOf(\n        PropTypes.shape({\n            on: PropTypes.oneOfType([PropTypes.oneOf(['hover'])]).isRequired,\n            style: PropTypes.shape({\n                itemTextColor: PropTypes.string,\n                itemBackground: PropTypes.string,\n                itemOpacity: PropTypes.number,\n                symbolSize: PropTypes.number,\n                symbolBorderWidth: PropTypes.number,\n                symbolBorderColor: PropTypes.string,\n            }).isRequired,\n        })\n    ),\n}\n"],"mappings":";;;;;;;IAEaA,CAAA,GAAe,SAAAC,CAAHC,CAAA;IAQN,IAPfC,CAAA,GAACD,CAAA,CAADE,CAAA;MACAC,CAAA,GAACH,CAAA,CAADI,CAAA;MACAC,CAAA,GAAIL,CAAA,CAAJM,IAAA;MACAC,CAAA,GAAIP,CAAA,CAAJQ,IAAA;MAAIC,CAAA,GAAAT,CAAA,CACJU,OAAA;MAAAC,CAAA,QAAU,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAZ,CAAA,CACXa,WAAA;MAAAC,CAAA,QAAc,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAf,CAAA,CACfgB,WAAA;IAEA,OACIC,CAAA;MACIV,CAAA,EAAGF,CAAA,GAAO;MACVa,EAAA,EAAIjB,CAAA,GAAII,CAAA,GAAO;MACfc,EAAA,EAAIhB,CAAA,GAAIE,CAAA,GAAO;MACfG,IAAA,EAAMD,CAAA;MACNG,OAAA,EAASC,CAAA;MACTS,WAAA,EAAaN,CAAA;MACbO,MAAA,OAVM,MAAHN,CAAA,GAAG,gBAAaA,CAAA;MAWnBO,KAAA,EAAO;QACHC,aAAA,EAAe;MAAA;IAAA,EAI/B;EAAA;ECvBaC,CAAA,GAAgB,SAAAC,CAAHzB,CAAA;IAQP,IAPfC,CAAA,GAACD,CAAA,CAADE,CAAA;MACAC,CAAA,GAACH,CAAA,CAADI,CAAA;MACAC,CAAA,GAAIL,CAAA,CAAJM,IAAA;MACAC,CAAA,GAAIP,CAAA,CAAJQ,IAAA;MAAIC,CAAA,GAAAT,CAAA,CACJU,OAAA;MAAAC,CAAA,QAAU,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAZ,CAAA,CACXa,WAAA;MAAAC,CAAA,QAAc,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAf,CAAA,CACfgB,WAAA;IAEA,OACIC,CAAA;MAAGS,SAAA,EAAwB,eAAAzB,CAAA,GAAK,MAAAE,CAAA,GAAK;MAAAwB,QAAA,EACjCV,CAAA;QACIF,CAAA,EACO,4BAAAV,CAAA,GAAO,IACP,8BAAO,KAAPA,CAAA,GAAc,MAAAA,CAAA,GAAO,gCACrBA,CAAA,GAAO,IAAC,MAAIA,CAAA,GAAI,4BACT,KAAPA,CAAA,GAAU,MAAIA,CAAA,GAAO,IAAC,4BACtBA,CAAA,GAAO,IACZ;QACFG,IAAA,EAAMD,CAAA;QACNG,OAAA,EAASC,CAAA;QACTS,WAAA,EAAaN,CAAA;QACbO,MAAA,OAfE,MAAHN,CAAA,GAAG,gBAAaA,CAAA;QAgBfO,KAAA,EAAO;UACHC,aAAA,EAAe;QAAA;MAAA;IAAA,EAKnC;EAAA;EC7BaK,CAAA,GAAe,SAAAC,CAAH7B,CAAA;IAQN,IAPfC,CAAA,GAACD,CAAA,CAADE,CAAA;MACAC,CAAA,GAACH,CAAA,CAADI,CAAA;MACAC,CAAA,GAAIL,CAAA,CAAJM,IAAA;MACAC,CAAA,GAAIP,CAAA,CAAJQ,IAAA;MAAIC,CAAA,GAAAT,CAAA,CACJU,OAAA;MAAAC,CAAA,QAAU,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAZ,CAAA,CACXa,WAAA;MAAAC,CAAA,QAAc,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAf,CAAA,CACfgB,WAAA;IAEA,OACIC,CAAA;MACIf,CAAA,EAAGD,CAAA;MACHG,CAAA,EAAGD,CAAA;MACHK,IAAA,EAAMD,CAAA;MACNG,OAAA,EAASC,CAAA;MACTS,WAAA,EAAaN,CAAA;MACbO,MAAA,OATM,MAAHN,CAAA,GAAG,gBAAaA,CAAA;MAUnBe,KAAA,EAAOzB,CAAA;MACP0B,MAAA,EAAQ1B,CAAA;MACRiB,KAAA,EAAO;QACHC,aAAA,EAAe;MAAA;IAAA,EAI/B;EAAA;ECxBaS,CAAA,GAAiB,SAAAC,CAAHjC,CAAA;IAQR,IAPfC,CAAA,GAACD,CAAA,CAADE,CAAA;MACAC,CAAA,GAACH,CAAA,CAADI,CAAA;MACAC,CAAA,GAAIL,CAAA,CAAJM,IAAA;MACAC,CAAA,GAAIP,CAAA,CAAJQ,IAAA;MAAIC,CAAA,GAAAT,CAAA,CACJU,OAAA;MAAAC,CAAA,QAAU,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAZ,CAAA,CACXa,WAAA;MAAAC,CAAA,QAAc,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAf,CAAA,CACfgB,WAAA;IAEA,OACIC,CAAA;MAAGS,SAAA,EAAwB,eAAAzB,CAAA,GAAK,MAAAE,CAAA,GAAK;MAAAwB,QAAA,EACjCV,CAAA;QACIF,CAAA,EACG,wBAAAV,CAAA,GAAO,8BACPA,CAAA,GAAI,MAAIA,CAAA,GAAI,0BACVA,CAAA,GAAI,wBACNA,CAAA,GAAO,IACZ;QACEG,IAAA,EAAMD,CAAA;QACNG,OAAA,EAASC,CAAA;QACTS,WAAA,EAAaN,CAAA;QACbO,MAAA,OAdE,MAAHN,CAAA,GAAG,gBAAaA,CAAA;QAefO,KAAA,EAAO;UACHC,aAAA,EAAe;QAAA;MAAA;IAAA,EAKnC;EAAA;AAAA,SAAAW,EAAA;EAAA,OAAAA,CAAA,GAAAC,MAAA,CAAAC,MAAA,GAAAD,MAAA,CAAAC,MAAA,CAAAC,IAAA,eAAApB,CAAA;IAAA,SAAAjB,CAAA,MAAAA,CAAA,GAAAsC,SAAA,CAAAC,MAAA,EAAAvC,CAAA;MAAA,IAAAC,CAAA,GAAAqC,SAAA,CAAAtC,CAAA;MAAA,SAAAG,CAAA,IAAAF,CAAA,EAAAkC,MAAA,CAAAK,SAAA,CAAAC,cAAA,CAAAC,IAAA,CAAAzC,CAAA,EAAAE,CAAA,MAAAc,CAAA,CAAAd,CAAA,IAAAF,CAAA,CAAAE,CAAA;IAAA;IAAA,OAAAc,CAAA;EAAA,GAAAiB,CAAA,CAAAS,KAAA,OAAAL,SAAA;AAAA;AC5BO,IAAMlC,CAAA,GAWT;IACAmC,MAAA,EAAQ;IACRK,SAAA,EAAW;IACXC,SAAA,EAAW;IACXC,YAAA,EAAc;IACdC,QAAA,EAAU;IACVC,WAAA,EAAa;IACbC,WAAA,GAAa;IACbC,UAAA,EAAY,SAAAA,CAACjC,CAAA;MAAa,YAAQA,CAAO;IAAA;IACzCkC,UAAA,EAAY;IACZC,WAAA,EAAa;EAAA;ECTXC,CAAA,GAAc;IAChBC,GAAA,EAAK;IACLC,KAAA,EAAO;IACPC,MAAA,EAAQ;IACRC,IAAA,EAAM;EAAA;EAGGC,CAAA,GAAoB,SAAAC,CAAH1C,CAAA;IAQoD,IAlB7DjB,CAAA;MAWjBC,CAAA,GAASgB,CAAA,CAAT4B,SAAA;MACA1C,CAAA,GAAYc,CAAA,CAAZ2C,YAAA;MACSvD,CAAA,GAAQY,CAAA,CAAjB4C,OAAA;MACAtD,CAAA,GAASU,CAAA,CAAT6C,SAAA;MACArD,CAAA,GAASQ,CAAA,CAAT8C,SAAA;MACApD,CAAA,GAAUM,CAAA,CAAV+C,UAAA;IAGA,IAAwB,mBAAb3D,CAAA,KAlBK,oBADCL,CAAA,GAmB6BK,CAAA,KAlBjB4D,KAAA,CAAMC,OAAA,CAAQlE,CAAA,KAAkB,SAATA,CAAA,GAmBhD,MAAM,IAAImE,KAAA,CAAM;IAGpB,IAAMvD,CAAA,GACkB,mBAAbP,CAAA,GACD;QACIiD,GAAA,EAAKjD,CAAA;QACLkD,KAAA,EAAOlD,CAAA;QACPmD,MAAA,EAAQnD,CAAA;QACRoD,IAAA,EAAMpD;MAAA,IACT6B,CAAA,KAEMmB,CAAA,EACAhD,CAAA;MAGXS,CAAA,GAAoBF,CAAA,CAAQ6C,IAAA,GAAO7C,CAAA,CAAQ2C,KAAA;MAC3CxC,CAAA,GAAkBH,CAAA,CAAQ0C,GAAA,GAAM1C,CAAA,CAAQ4C,MAAA;MAC1CY,CAAA,GAAQ3D,CAAA,GAAYK,CAAA;MACpBuD,CAAA,GAAS1D,CAAA,GAAaI,CAAA;MACpBjB,CAAA,IAAWS,CAAA,GAAY,KAAKJ,CAAA;IAOlC,OANkB,UAAdF,CAAA,GACAmE,CAAA,GAAQ3D,CAAA,GAAYF,CAAA,GAAYT,CAAA,GAAUgB,CAAA,GACrB,aAAdb,CAAA,KACPoE,CAAA,GAAS1D,CAAA,GAAaJ,CAAA,GAAYT,CAAA,GAAUiB,CAAA,GAGzC;MAAEe,KAAA,EAAAsC,CAAA;MAAOrC,MAAA,EAAAsC,CAAA;MAAQR,OAAA,EAAAjD;IAAA,CAC5B;EAAA;EAEaV,CAAA,GAA4B,SAAAoE,CAAHrD,CAAA;IAWhC,IAVFjB,CAAA,GAAMiB,CAAA,CAANsD,MAAA;MACAtE,CAAA,GAAUgB,CAAA,CAAVuD,UAAA;MACArE,CAAA,GAAUc,CAAA,CAAVwD,UAAA;MACApE,CAAA,GAAcY,CAAA,CAAdyD,cAAA;MACAnE,CAAA,GAAeU,CAAA,CAAf0D,eAAA;MACAlE,CAAA,GAAKQ,CAAA,CAALa,KAAA;MACAnB,CAAA,GAAMM,CAAA,CAANc,MAAA;MAKInB,CAAA,GAAIX,CAAA;MACJa,CAAA,GAAIX,CAAA;IAER,QAAQH,CAAA;MACJ,KAAK;QACDY,CAAA,KAAMP,CAAA,GAAiBI,CAAA,IAAS;QAChC;MAEJ,KAAK;QACDG,CAAA,IAAKP,CAAA,GAAiBI,CAAA;QACtB;MAEJ,KAAK;QACDG,CAAA,IAAKP,CAAA,GAAiBI,CAAA,EACtBK,CAAA,KAAMP,CAAA,GAAkBI,CAAA,IAAU;QAClC;MAEJ,KAAK;QACDC,CAAA,IAAKP,CAAA,GAAiBI,CAAA,EACtBK,CAAA,IAAKP,CAAA,GAAkBI,CAAA;QACvB;MAEJ,KAAK;QACDC,CAAA,KAAMP,CAAA,GAAiBI,CAAA,IAAS,GAChCK,CAAA,IAAKP,CAAA,GAAkBI,CAAA;QACvB;MAEJ,KAAK;QACDG,CAAA,IAAKP,CAAA,GAAkBI,CAAA;QACvB;MAEJ,KAAK;QACDG,CAAA,KAAMP,CAAA,GAAkBI,CAAA,IAAU;QAClC;MAEJ,KAAK;QACDC,CAAA,KAAMP,CAAA,GAAiBI,CAAA,IAAS,GAChCK,CAAA,KAAMP,CAAA,GAAkBI,CAAA,IAAU;IAAA;IAI1C,OAAO;MAAET,CAAA,EAAAU,CAAA;MAAGR,CAAA,EAAAU;IAAA,CAChB;EAAA;EAEa8D,CAAA,GAAoB,SAAAC,CAAH5D,CAAA;IAU8C,IACpEjB,CAAA;MACAC,CAAA;MAEAE,CAAA;MACAE,CAAA;MACAE,CAAA;MACAE,CAAA;MAhBJE,CAAA,GAASM,CAAA,CAAT4B,SAAA;MACAjC,CAAA,GAAOK,CAAA,CAAP6D,OAAA;MACAhE,CAAA,GAAUG,CAAA,CAAV8D,UAAA;MACAhE,CAAA,GAAaE,CAAA,CAAb+D,aAAA;MACAZ,CAAA,GAAKnD,CAAA,CAALa,KAAA;MACAuC,CAAA,GAAMpD,CAAA,CAANc,MAAA;IAaA,QAAQpB,CAAA;MACJ,KAAK;QACDX,CAAA,GAAU,GACVC,CAAA,IAAWoE,CAAA,GAASvD,CAAA,IAAc,GAElCT,CAAA,GAASgE,CAAA,GAAS,GAClB5D,CAAA,GAAiB,WACbG,CAAA,IACAT,CAAA,GAASiE,CAAA,EACT7D,CAAA,GAAc,UAEdJ,CAAA,GAASW,CAAA,GAAaC,CAAA,EACtBR,CAAA,GAAc;QAElB;MAEJ,KAAK;QACDP,CAAA,GAAUoE,CAAA,GAAQtD,CAAA,EAClBb,CAAA,IAAWoE,CAAA,GAASvD,CAAA,IAAc,GAElCT,CAAA,GAASgE,CAAA,GAAS,GAClB5D,CAAA,GAAiB,WACbG,CAAA,IACAT,CAAA,GAAS,GACTI,CAAA,GAAc,YAEdJ,CAAA,GAASiE,CAAA,GAAQtD,CAAA,GAAaC,CAAA,EAC9BR,CAAA,GAAc;QAElB;MAEJ,KAAK;QACDP,CAAA,IAAWoE,CAAA,GAAQtD,CAAA,IAAc,GACjCb,CAAA,GAAU,GAEVE,CAAA,GAASiE,CAAA,GAAQ,GAEjB7D,CAAA,GAAc,UACVK,CAAA,IACAP,CAAA,GAASgE,CAAA,EACT5D,CAAA,GAAiB,iBAEjBJ,CAAA,GAASS,CAAA,GAAaC,CAAA,EACtBN,CAAA,GAAiB;QAErB;MAEJ,KAAK;QACDT,CAAA,IAAWoE,CAAA,GAAQtD,CAAA,IAAc,GACjCb,CAAA,GAAUoE,CAAA,GAASvD,CAAA,EAEnBX,CAAA,GAASiE,CAAA,GAAQ,GACjB7D,CAAA,GAAc,UACVK,CAAA,IACAP,CAAA,GAAS,GACTI,CAAA,GAAiB,uBAEjBJ,CAAA,GAASgE,CAAA,GAASvD,CAAA,GAAaC,CAAA,EAC/BN,CAAA,GAAiB;IAAA;IAK7B,OAAO;MACHwE,OAAA,EAAAjF,CAAA;MACAkF,OAAA,EAAAjF,CAAA;MACAkF,MAAA,EAAAhF,CAAA;MACAiF,MAAA,EAAA/E,CAAA;MACAgF,WAAA,EAAA9E,CAAA;MACA+E,cAAA,EAAA7E;IAAA,CAER;EAAA;EAEa8E,CAAA,GAAgC,SAAAC,CAAHvE,CAAA;IAcP,IAa3BjB,CAAA;MA1BJK,CAAA,GAAKY,CAAA,CAALwE,KAAA;MACAlF,CAAA,GAAKU,CAAA,CAALyE,KAAA;MAAK/E,CAAA,GAAAM,CAAA,CACLsB,MAAA;MAAA3B,CAAA,QAAM,MAAAD,CAAA,GAAGP,CAAA,CAA+BmC,MAAA,GAAM5B,CAAA;MAAAG,CAAA,GAAAG,CAAA,CAC9C2B,SAAA;MAAA7B,CAAA,QAAS,MAAAD,CAAA,GAAGV,CAAA,CAA+BwC,SAAA,GAAS9B,CAAA;MAAAsD,CAAA,GAAAnD,CAAA,CACpD4B,SAAA;MAAAwB,CAAA,QAAS,MAAAD,CAAA,GAAGhE,CAAA,CAA+ByC,SAAA,GAASuB,CAAA;MAAAtE,CAAA,GAAAmB,CAAA,CACpD6B,YAAA;MAAAtB,CAAA,QAAY,MAAA1B,CAAA,GAAGM,CAAA,CAA+B0C,YAAA,GAAYhD,CAAA;MAAA8B,CAAA,GAAAX,CAAA,CAC1D8B,QAAA;MAAAf,CAAA,QAAQ,MAAAJ,CAAA,GAAGxB,CAAA,CAA+B2C,QAAA,GAAQnB,CAAA;MAAAM,CAAA,GAAAjB,CAAA,CAClD+B,WAAA;MAAAK,CAAA,QAAW,MAAAnB,CAAA,GAAG9B,CAAA,CAA+B4C,WAAA,GAAWd,CAAA;MAAAwB,CAAA,GAAAzC,CAAA,CACxDgC,WAAA;MAAA/C,CAAA,QAAW,MAAAwD,CAAA,GAAGtD,CAAA,CAA+B6C,WAAA,GAAWS,CAAA;MAAAkB,CAAA,GAAA3D,CAAA,CACxDiC,UAAA;MAAAqC,CAAA,QAAU,MAAAX,CAAA,GAAGxE,CAAA,CAA+B8C,UAAA,GAAU0B,CAAA;MACtDe,CAAA,GAAK1E,CAAA,CAAL2E,KAAA;MAAKC,CAAA,GAAA5E,CAAA,CACLkC,UAAA;MAAA2C,CAAA,QAAU,MAAAD,CAAA,GAAGzF,CAAA,CAA+B+C,UAAA,GAAU0C,CAAA;MAAAE,CAAA,GAAA9E,CAAA,CACtDmC,WAAA;MAAA4C,CAAA,QAAW,MAAAD,CAAA,GAAG3F,CAAA,CAA+BgD,WAAA,GAAW2C,CAAA;MAGlDE,CAAA,GAAuB,aAAd5B,CAAA,GAAyB,GAAA6B,MAAA,CAAI7F,CAAA,CAAM8F,MAAA,IAAUC,OAAA,KAAY/F,CAAA,CAAM8F,MAAA;MAExEE,CAAA,GAAgBpG,CAAA,GAAckG,MAAA,CAAOF,CAAA;IACrB,MAAlBA,CAAA,CAAO1D,MAAA,GAEP8D,CAAA,CAAcC,KAAA,CAAM,CAAC,GAAG1F,CAAA,KACC,MAAlBqF,CAAA,CAAO1D,MAAA,IAEd8D,CAAA,CAAcC,KAAA,CAAM,CAAC,GAAG1F,CAAA,GAAS,GAAGA,CAAA,IAMpCZ,CAAA,GAFA,gBAAgBK,CAAA,IAEN4F,CAAA,CAAO,IAAEC,MAAA,CAAK7F,CAAA,CAAMkG,UAAA,IAAY,CAAEN,CAAA,CAAO,OAG1ChC,KAAA,CAAMC,OAAA,CAAQ3D,CAAA,IAASA,CAAA,GAASF,CAAA,CAAcqF,KAAA,CAAMnF,CAAA;IAGjE,IAgBIiG,CAAA;MACAC,CAAA;MAOAC,CAAA;MACAC,CAAA;MACAC,CAAA;MACAC,CAAA;MA3BEC,CAAA,GAAarG,CAAA,CAAsCJ,CAAA,EAAO;MAE1D0G,CAAA,GAAc5G,CAAA,CAAkBoF,CAAA;MAEhCyB,CAAA,GAUA;MAMFC,CAAA,GAAa;MACbC,CAAA,GAAa;IAQjB,IAAkB,UAAd7C,CAAA,EAAqB;MAMrB,IAAI8C,CAAA,EACAC,CAAA,EAEAC,CAAA;MARJb,CAAA,GAAQ5F,CAAA,EACR6F,CAAA,GAAS1F,CAAA,EAETmG,CAAA,GAAa;MAMb,IACII,CAAA;MAEJV,CAAA,GAAgB,GAEZF,CAAA,GADe,YAAfZ,CAAA,GACS,IACa,aAAfA,CAAA,GACElF,CAAA,GAAS,IAETA,CAAA,EAGQ,aAAjBY,CAAA,IACA2F,CAAA,IAAMnF,CAAA,EACNoF,CAAA,GAAKlH,CAAA,GAAca,CAAA,GAAY,GAE/BsG,CAAA,IAASrF,CAAA,GAAWqB,CAAA,EACpBiE,CAAA,GAAoB,cAEpBX,CAAA,GAAS5F,CAAA,GAAYiF,CAAA,EACrBa,CAAA,GAAqB,cAErBM,CAAA,GAAKjH,CAAA,GAAc,IAAIa,CAAA,EAGvBsG,CAAA,IAFAD,CAAA,GAAKrG,CAAA,GAAYiB,CAAA,IAEJqB,CAAA,EACbiE,CAAA,GAAoB,WAEpBX,CAAA,IAAUX,CAAA,EACVa,CAAA,GAAqB,eAGzB7G,CAAA,CAAOuH,OAAA,CAAQ,UAAAtG,CAAA;QACX,IAAMjB,CAAA,GAAIqG,CAAA,CAAcpF,CAAA;QAExB+F,CAAA,CAAcQ,IAAA,CAAK;UACfC,EAAA,EAAIzH,CAAA;UACJ0H,EAAA,EAAAP,CAAA;UACAQ,EAAA,EAAI3H,CAAA;UACJ4H,EAAA,EAAAR,CAAA;UACAS,IAAA,EAAMd,CAAA,CAAY9F,CAAA;UAClB6G,KAAA,EAAO9H,CAAA;UACP+H,KAAA,EAAAV,CAAA;UACAW,mBAAA,EA3CoB;UA4CpBC,iBAAA,EAAAX;QAAA,EAER;MAAA,EACJ;IAAA,OAAO;MAMH,IAAIY,CAAA,EACAC,CAAA,EAEAC,CAAA,EACAC,CAAA;MATJ7B,CAAA,GAAQzF,CAAA,EACR0F,CAAA,GAAS7F,CAAA,EAETqG,CAAA,GAAa;MASbL,CAAA,IAAiB,IAEbD,CAAA,GADe,YAAfb,CAAA,GACSlF,CAAA,GACa,aAAfkF,CAAA,GACElF,CAAA,GAAS,IAET,GAGQ,aAAjBY,CAAA,IAEA2G,CAAA,GAAKjI,CAAA,GAAca,CAAA,GAAY,GAE/BqH,CAAA,IAHAF,CAAA,IAAMlG,CAAA,IAGOqB,CAAA,EACbgF,CAAA,GAAsB,OAEtB3B,CAAA,GAAS3F,CAAA,GAAYiF,CAAA,EACrBa,CAAA,GAAqB,cAErBqB,CAAA,GAAKhI,CAAA,GAAc,IAAIa,CAAA,EAGvBqH,CAAA,IAFAD,CAAA,GAAKpH,CAAA,GAAYiB,CAAA,IAEJqB,CAAA,EACbgF,CAAA,GAAsB,SAEtB3B,CAAA,IAAUV,CAAA,EACVa,CAAA,GAAqB,eAGzB7G,CAAA,CAAOuH,OAAA,CAAQ,UAAAtG,CAAA;QACX,IAAMjB,CAAA,GAAIqG,CAAA,CAAcpF,CAAA;QAExB+F,CAAA,CAAcQ,IAAA,CAAK;UACfC,EAAA,EAAAS,CAAA;UACAR,EAAA,EAAI1H,CAAA;UACJ2H,EAAA,EAAAQ,CAAA;UACAP,EAAA,EAAI5H,CAAA;UACJ6H,IAAA,EAAMd,CAAA,CAAY9F,CAAA;UAClB6G,KAAA,EAAAM,CAAA;UACAL,KAAA,EAAO/H,CAAA;UACPgI,mBAAA,EAAAK,CAAA;UACAJ,iBAAA,EA3CkB;QAAA,EA6C1B;MAAA,EACJ;IAAA;IAEA,OAAO;MACHnG,KAAA,EAAA0E,CAAA;MACAzE,MAAA,EAAA0E,CAAA;MACA6B,UAAA,EAjIe;MAkIfC,UAAA,EAAAtB,CAAA;MACAuB,UAAA,EAAAtB,CAAA;MACAuB,UAAA,EAjIe;MAkIfC,UAAA,EAAA5B,CAAA;MACApB,KAAA,EAAOsB,CAAA;MACP2B,SAAA,EAAWhD,CAAA;MACXiD,MAAA,EAAAlC,CAAA;MACAmC,MAAA,EAAAlC,CAAA;MACAmC,aAAA,EAAAlC,CAAA;MACAmC,oBAAA,EAAsBjD,CAAA;MACtBkD,kBAAA,EAAAnC;IAAA,CAER;EAAA;EChZalB,CAAA,GAA4B,SAAAsD,CAAHhJ,CAAA;IAcH,IAb/BE,CAAA,GAAKF,CAAA,CAALwF,KAAA;MACAlF,CAAA,GAAKN,CAAA,CAALyF,KAAA;MAAKjF,CAAA,GAAAR,CAAA,CACLsC,MAAA;MAAA5B,CAAA,QAAM,MAAAF,CAAA,GAAGL,CAAA,CAA+BmC,MAAA,GAAM9B,CAAA;MAAAK,CAAA,GAAAb,CAAA,CAC9C2C,SAAA;MAAA7B,CAAA,QAAS,MAAAD,CAAA,GAAGV,CAAA,CAA+BwC,SAAA,GAAS9B,CAAA;MAAAsD,CAAA,GAAAnE,CAAA,CACpD4C,SAAA;MAAAwB,CAAA,QAAS,MAAAD,CAAA,GAAGhE,CAAA,CAA+ByC,SAAA,GAASuB,CAAA;MAAAtE,CAAA,GAAAG,CAAA,CACpD6C,YAAA;MAAAtB,CAAA,QAAY,MAAA1B,CAAA,GAAGM,CAAA,CAA+B0C,YAAA,GAAYhD,CAAA;MAAA8B,CAAA,GAAA3B,CAAA,CAC1D8C,QAAA;MAAAf,CAAA,QAAQ,MAAAJ,CAAA,GAAGxB,CAAA,CAA+B2C,QAAA,GAAQnB,CAAA;MAAAyB,CAAA,GAAApD,CAAA,CAClD+C,WAAA;MAAAU,CAAA,QAAW,MAAAL,CAAA,GAAGjD,CAAA,CAA+B4C,WAAA,GAAWK,CAAA;MAAAnD,CAAA,GAAAD,CAAA,CACxDgD,WAAA;MAAA2B,CAAA,QAAW,MAAA1E,CAAA,GAAGE,CAAA,CAA+B6C,WAAA,GAAW/C,CAAA;MAAAyF,CAAA,GAAA1F,CAAA,CACxDiD,UAAA;MAAA2C,CAAA,QAAU,MAAAF,CAAA,GAAGvF,CAAA,CAA+B8C,UAAA,GAAUyC,CAAA;MACtDG,CAAA,GAAK7F,CAAA,CAAL2F,KAAA;MAAKG,CAAA,GAAA9F,CAAA,CACLkD,UAAA;MAAA6C,CAAA,QAAU,MAAAD,CAAA,GAAG3F,CAAA,CAA+B+C,UAAA,GAAU4C,CAAA;MAAAE,CAAA,GAAAhG,CAAA,CACtDmD,WAAA;MAEAiD,CAAA,GAeId,CAAA,CAA8B;QAC9BE,KAAA,EAAAtF,CAAA;QACAuF,KAAA,EAAAnF,CAAA;QACAgC,MAAA,EAAA5B,CAAA;QACAiC,SAAA,EAAA7B,CAAA;QACA8B,SAAA,EAAAwB,CAAA;QACAvB,YAAA,EAAAtB,CAAA;QACAuB,QAAA,EAAAf,CAAA;QACAgB,WAAA,EAAAU,CAAA;QACAT,WAAA,EAAA2B,CAAA;QACA1B,UAAA,EAAA2C,CAAA;QACAD,KAAA,EAAAE,CAAA;QACA3C,UAAA,EAAA6C,CAAA;QACA5C,WAAA,OA9BO,MAAA6C,CAAA,GAAG7F,CAAA,CAA+BgD,WAAA,GAAW6C;MAAA;MAGpDO,CAAA,GAAKH,CAAA,CAALvE,KAAA;MACA2E,CAAA,GAAMJ,CAAA,CAANtE,MAAA;MACA2E,CAAA,GAAUL,CAAA,CAAViC,UAAA;MACA3B,CAAA,GAAUN,CAAA,CAAVkC,UAAA;MACA3B,CAAA,GAAUP,CAAA,CAAVmC,UAAA;MACA3B,CAAA,GAAUR,CAAA,CAAVoC,UAAA;MACO3B,CAAA,GAAaT,CAAA,CAApBX,KAAA;MACAqB,CAAA,GAAUV,CAAA,CAAVqC,UAAA;MACA1B,CAAA,GAASX,CAAA,CAATsC,SAAA;MACA1B,CAAA,GAAMZ,CAAA,CAANuC,MAAA;MACA1B,CAAA,GAAMb,CAAA,CAANwC,MAAA;MACA1B,CAAA,GAAad,CAAA,CAAbyC,aAAA;MACA1B,CAAA,GAAkBf,CAAA,CAAlB2C,kBAAA;MACA3B,CAAA,GAAoBhB,CAAA,CAApB0C,oBAAA;MAiBEzB,CAAA,GAAQjH,CAAA;MAER6H,CAAA,0CAA0C7D,CAAA,GAAS,MAAI0C,CAAA,CACxDmC,GAAA,CAAI,UAAAjI,CAAA;QAAI,OAAIA,CAAA,CAAKkI,MAAM;MAAA,GACvBC,IAAA,CAAK;IAEV,OACIpJ,CAAA;MAAA2B,QAAA,GACIV,CAAA;QAAAU,QAAA,EACIV,CAAA;UACIoI,EAAA,EAAInB,CAAA;UACJT,EAAA,EAAIf,CAAA;UACJgB,EAAA,EAAIf,CAAA;UACJgB,EAAA,EAAIf,CAAA;UACJgB,EAAA,EAAIf,CAAA;UAAWlF,QAAA,EAEdoF,CAAA,CAAWmC,GAAA,CAAI,UAAAlJ,CAAA;YAAS,OACrBiB,CAAA,SAAAiB,CAAA,CAAU,IAAAlC,CAAA;UAAA;QAAA;MAAA,IAIrBgH,CAAA,IACG/F,CAAA;QACIS,SAAA,iBAAwBuF,CAAA,GAAM,OAAKC,CAAA,GAAM,cAAYC,CAAA,GAAiB;QACtEmC,UAAA,EAAYjC,CAAA;QACZkC,gBAAA,EAAkBnC,CAAA;QAClB9F,KAAA,EAAOgG,CAAA,CAAMkC,OAAA,CAAQ5D,KAAA,CAAMiC,IAAA;QAAKlG,QAAA,EAE/BqF;MAAA,IAGT/F,CAAA;QAAMa,KAAA,EAAO0E,CAAA;QAAOzE,MAAA,EAAQ0E,CAAA;QAAQjG,IAAA,EAAc,UAAA0H;MAAA,IACjDpB,CAAA,CAAcoC,GAAA,CAAI,UAACjJ,CAAA,EAAME,CAAA;QAAK,OAC3BH,CAAA,CAACY,CAAA,EAAQ;UAAAe,QAAA,GACLV,CAAA;YACIwG,EAAA,EAAIxH,CAAA,CAAKwH,EAAA;YACTC,EAAA,EAAIzH,CAAA,CAAKyH,EAAA;YACTC,EAAA,EAAI1H,CAAA,CAAK0H,EAAA;YACTC,EAAA,EAAI3H,CAAA,CAAK2H,EAAA;YACTtG,KAAA,EAAOgG,CAAA,CAAMkC,OAAA,CAAQ9D,KAAA,CAAM+D;UAAA,IAE/BxI,CAAA;YACIf,CAAA,EAAGD,CAAA,CAAK6H,KAAA;YACR1H,CAAA,EAAGH,CAAA,CAAK8H,KAAA;YACRuB,UAAA,EAAYrJ,CAAA,CAAK+H,mBAAA;YACjBuB,gBAAA,EAAkBtJ,CAAA,CAAKgI,iBAAA;YACvB3G,KAAA,EAAOgG,CAAA,CAAMkC,OAAA,CAAQ9D,KAAA,CAAMmC,IAAA;YAAKlG,QAAA,EAE/B1B,CAAA,CAAK4H;UAAA;QAAA,GAfC1H,CAAA,CAiBJ;MAAA;IAAA,EAI3B;EAAA;EAAA0F,CAAA;ECrGaC,CAAA,GAAoC,SAAA4D,CAAH1J,CAAA;IAUH,IACnCC,CAAA;MACAE,CAAA;MAXJE,CAAA,GAAcL,CAAA,CAAd0E,cAAA;MACAnE,CAAA,GAAeP,CAAA,CAAf2E,eAAA;MACAlE,CAAA,GAAMT,CAAA,CAANuE,MAAA;MAAM5D,CAAA,GAAAX,CAAA,CACNwE,UAAA;MAAA5D,CAAA,QAAa,MAAHD,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAd,CAAA,CACdyE,UAAA;MAAA1D,CAAA,QAAa,MAAHD,CAAA,GAAG,IAACA,CAAA;MAAAsD,CAAA,GAAApE,CAAA,CACduC,MAAA;MAAA8B,CAAA,QAAM,MAAAD,CAAA,GAAGhE,CAAA,CAA+BmC,MAAA,GAAM6B,CAAA;MAAAtE,CAAA,GAAAE,CAAA,CAC9C4C,SAAA;MAAApB,CAAA,QAAS,MAAA1B,CAAA,GAAGM,CAAA,CAA+BwC,SAAA,GAAS9C,CAAA;MAAA8B,CAAA,GAAA5B,CAAA,CACpD6C,SAAA;MAAAb,CAAA,QAAS,MAAAJ,CAAA,GAAGxB,CAAA,CAA+ByC,SAAA,GAASjB,CAAA;MACjDyB,CAAA,aAAApC,CAAA,EAAAjB,CAAA;QAAA,YAAAiB,CAAA;QAAA,IAAAhB,CAAA;UAAAE,CAAA;UAAAE,CAAA;UAAAE,CAAA,GAAA4B,MAAA,CAAAwH,IAAA,CAAA1I,CAAA;QAAA,KAAAd,CAAA,MAAAA,CAAA,GAAAI,CAAA,CAAAgC,MAAA,EAAApC,CAAA,IAAAF,CAAA,GAAAM,CAAA,CAAAJ,CAAA,GAAAH,CAAA,CAAA4J,OAAA,CAAA3J,CAAA,WAAAI,CAAA,CAAAJ,CAAA,IAAAgB,CAAA,CAAAhB,CAAA;QAAA,OAAAI,CAAA;MAAA,CAAW,CAAAL,CAAA,EAAA6F,CAAA;IAII,UAAd7D,CAAA,IACA/B,CAAA,GAAQoE,CAAA,EACRlE,CAAA,GAASqB,CAAA,KAETvB,CAAA,GAAQuB,CAAA,EACRrB,CAAA,GAASkE,CAAA;IAGb,IAAAX,CAAA,GAAiBxD,CAAA,CAA0B;QACvCqE,MAAA,EAAA9D,CAAA;QACA+D,UAAA,EAAA5D,CAAA;QACA6D,UAAA,EAAA1D,CAAA;QACA2D,cAAA,EAAArE,CAAA;QACAsE,eAAA,EAAApE,CAAA;QACAuB,KAAA,EAAA7B,CAAA;QACA8B,MAAA,EAAA5B;MAAA;MAPIyE,CAAA,GAAClB,CAAA,CAADxD,CAAA;MAAGqF,CAAA,GAAC7B,CAAA,CAADtD,CAAA;IAUX,OACIa,CAAA;MAAGS,SAAA,EAAwB,eAAAkD,CAAA,GAAM,OAAAW,CAAA,GAAK;MAAA5D,QAAA,EAClCV,CAAA,CAAC0E,CAAA,EAAyBzD,CAAA;QACtBK,MAAA,EAAQ8B,CAAA;QACRzB,SAAA,EAAWpB,CAAA;QACXqB,SAAA,EAAWb;MAAA,GACPqB,CAAA;IAAA,EAIpB;EAAA;EC9BM0C,CAAA,GAAgB;IAClB8D,MAAA,EAAQ/J,CAAA;IACRgK,OAAA,EAAStI,CAAA;IACTuI,MAAA,EAAQnI,CAAA;IACRoI,QAAA,EAAUhI;EAAA;EAGDgE,CAAA,GAAgB,SAAAiE,CAAHhK,CAAA;IAwBA,IAAAE,CAAA;MAAAI,CAAA;MAAAE,CAAA;MAAAG,CAAA;MAAAwD,CAAA;MAAAC,CAAA;MAAAvE,CAAA;MAAA0B,CAAA;MAAAI,CAAA;MAAAI,CAAA;MAAA5B,CAAA;MAvBtBiD,CAAA,GAACpD,CAAA,CAADC,CAAA;MACAwD,CAAA,GAACzD,CAAA,CAADG,CAAA;MACAF,CAAA,GAAKD,CAAA,CAAL6B,KAAA;MACAyD,CAAA,GAAMtF,CAAA,CAAN8B,MAAA;MACA4D,CAAA,GAAI1F,CAAA,CAAJiK,IAAA;MAAIrE,CAAA,GAAA5F,CAAA,CACJ4C,SAAA;MAAAiD,CAAA,QAAY,MAAHD,CAAA,GAAG,kBAAeA,CAAA;MAAAG,CAAA,GAAA/F,CAAA,CAC3B6E,OAAA;MAAAmB,CAAA,QAAU,MAAHD,CAAA,IAAQA,CAAA;MACfK,CAAA,GAASpG,CAAA,CAATkK,SAAA;MAAS3D,CAAA,GAAAvG,CAAA,CACTmK,UAAA;MAAA3D,CAAA,QAAa,MAAHD,CAAA,GAAG,gBAAaA,CAAA;MAAAE,CAAA,GAAAzG,CAAA,CAC1BS,OAAA;MAAAiG,CAAA,QAAU,MAAHD,CAAA,GAAG,IAACA,CAAA;MAAAE,CAAA,GAAA3G,CAAA,CAEXoK,WAAA;MAAAxD,CAAA,QAAc,MAAHD,CAAA,GAAG,WAAQA,CAAA;MAAAE,CAAA,GAAA7G,CAAA,CACtB8E,UAAA;MAAAgC,CAAA,QAAa,MAAHD,CAAA,GAAG,KAAEA,CAAA;MAAAE,CAAA,GAAA/G,CAAA,CACf+E,aAAA;MAAAiC,CAAA,QAAgB,MAAHD,CAAA,GAAG,IAACA,CAAA;MAAAE,CAAA,GAAAjH,CAAA,CACjBqK,iBAAA;MAAAnD,CAAA,QAAoB,MAAHD,CAAA,GAAG,IAACA,CAAA;MAAAE,CAAA,GAAAnH,CAAA,CACrBsK,iBAAA;MAAAlD,CAAA,QAAoB,MAAHD,CAAA,GAAG,gBAAaA,CAAA;MAEjCE,CAAA,GAAOrH,CAAA,CAAPuK,OAAA;MACAtC,CAAA,GAAYjI,CAAA,CAAZwK,YAAA;MACAtC,CAAA,GAAYlI,CAAA,CAAZyK,YAAA;MACAtC,CAAA,GAAWnI,CAAA,CAAX0K,WAAA;MAEAtC,CAAA,GAAOpI,CAAA,CAAP2K,OAAA;MAEAC,CAAA,GAA0B/J,CAAA,CAAgB;MAAnCgK,CAAA,GAAKD,CAAA;MAAEE,CAAA,GAAQF,CAAA;MAChBG,CAAA,GAAQ3K,CAAA;MAER4K,EAAA,GAAmBlK,CAAA,CACrB,UAACE,CAAA;QACG,IAAIoH,CAAA,EAAS;UACT,IACMrI,CAAA,GADeqI,CAAA,CAAQ6C,MAAA,CAAO,UAAAjK,CAAA;YAAK,OAAc,YAAdA,CAAA,CAAFkK,EAAA;UAAA,GACZC,MAAA,CACvB,UAACnK,CAAA,EAAKjB,CAAA;YAAM,OAAAkC,CAAA,CACL,IAAAjB,CAAA,EACAjB,CAAA,CAAOsB,KAAA,CACZ;UAAA,GACF,CACJ;UACAyJ,CAAA,CAAS/K,CAAA,CACb;QAAA;QAAA,QAEAkI,CAAA,IAAAA,CAAA,CAAevC,CAAA,EAAM1E,CAAA,CACxB;MAAA,GACD,CAACiH,CAAA,EAAcvC,CAAA,EAAM0C,CAAA;MAEnBgD,EAAA,GAAmBtK,CAAA,CACrB,UAACE,CAAA;QACG,IAAIoH,CAAA,EAAS;UACT,IACMrI,CAAA,GADeqI,CAAA,CAAQ6C,MAAA,CAAO,UAAAjK,CAAA;YAAK,OAAc,YAAdA,CAAA,CAAFkK,EAAA;UAAA,GACZC,MAAA,CACvB,UAACnK,CAAA,EAAKjB,CAAA;YAAM,OAAAkC,CAAA,CACL,IAAAjB,CAAA,EACAjB,CAAA,CAAOsB,KAAA,CACZ;UAAA,GACF,CACJ;UACAyJ,CAAA,CAAS/K,CAAA,CACb;QAAA;QAAA,QAEAmI,CAAA,IAAAA,CAAA,CAAexC,CAAA,EAAM1E,CAAA,CACxB;MAAA,GACD,CAACkH,CAAA,EAAcxC,CAAA,EAAM0C,CAAA;MAGzBiD,EAAA,GAA0E1G,CAAA,CAAkB;QACxF/B,SAAA,EAAAiD,CAAA;QACAhB,OAAA,EAAAmB,CAAA;QACAlB,UAAA,EAA4B,SAAlB5E,CAAA,GAAE2K,CAAA,CAAM/F,UAAA,IAAU5E,CAAA,GAAI4G,CAAA;QAChC/B,aAAA,EAAAiC,CAAA;QACAnF,KAAA,EAAA5B,CAAA;QACA6B,MAAA,EAAAwD;MAAA;MANIgG,EAAA,GAAOD,EAAA,CAAPrG,OAAA;MAASuG,EAAA,GAAOF,EAAA,CAAPpG,OAAA;MAASuG,EAAA,GAAMH,EAAA,CAANnG,MAAA;MAAQuG,EAAA,GAAMJ,EAAA,CAANlG,MAAA;MAAQuG,EAAA,GAAWL,EAAA,CAAXjG,WAAA;MAAauG,EAAA,GAAcN,EAAA,CAAdhG,cAAA;MASjDuG,EAAA,GAAgB,CAACvE,CAAA,EAASY,CAAA,EAAcC,CAAA,EAAcC,CAAA,EAAa0D,IAAA,CACrE,UAAA7K,CAAA;QAAO,YAAgB,MAAZA,CAAqB;MAAA;MAG9B8K,EAAA,GAAqC,qBAAhBlF,CAAA,GAA6BA,CAAA,GAAcd,CAAA,CAAcc,CAAA;IAEpF,OACI7G,CAAA;MACI0B,SAAA,EAAwB,eAAA2B,CAAA,GAAK,MAAAK,CAAA,GAAK;MAClCpC,KAAA,EAAO;QACHZ,OAAA,EAA0B,SAAnBH,CAAA,GAAEuK,CAAA,CAAMkB,WAAA,IAAWzL,CAAA,GAAIoG;MAAA;MAChChF,QAAA,GAEFV,CAAA;QACIa,KAAA,EAAO5B,CAAA;QACP6B,MAAA,EAAQwD,CAAA;QACR/E,IAAA,EAA0B,SAAtBC,CAAA,GAAEqK,CAAA,CAAMmB,cAAA,IAAcxL,CAAA,GAAIgG,CAAA;QAC9BnF,KAAA,EAAO;UACH4K,MAAA,EAAQL,EAAA,GAAgB,YAAY;QAAA;QAExCrB,OAAA,EAAS,SAAAA,CAAAvJ,CAAA;UAAA,QACLqG,CAAA,IAAAA,CAAA,CAAU3B,CAAA,EAAM1E,CAAA,WAChBmH,CAAA,IAAAA,CAAA,CAAczC,CAAA,CAAK0D,EAAA,CACrB;QAAA;QACFoB,YAAA,EAAcQ,EAAA;QACdP,YAAA,EAAcW;MAAA,IAEjB1K,CAAA,CAAMwL,aAAA,CAAcJ,EAAA,EAAW7J,CAAA;QAC5BmH,EAAA,EAAI1D,CAAA,CAAK0D,EAAA;QACTnJ,CAAA,EAAGqL,EAAA;QACHnL,CAAA,EAAGoL,EAAA;QACHlL,IAAA,EAAsB,SAAlBM,CAAA,GAAEkK,CAAA,CAAM/F,UAAA,IAAUnE,CAAA,GAAImG,CAAA;QAC1BvG,IAAA,EAA6B,SAAzB4D,CAAA,GAAW,SAAXC,CAAA,GAAEsB,CAAA,CAAKnF,IAAA,IAAI6D,CAAA,GAAIsB,CAAA,CAAKyG,KAAA,IAAKhI,CAAA,GAAI;QACjCvD,WAAA,EAAoC,SAAzBf,CAAA,GAAEgL,CAAA,CAAMR,iBAAA,IAAiBxK,CAAA,GAAIqH,CAAA;QACxCnG,WAAA,EAAoC,SAAzBQ,CAAA,GAAEsJ,CAAA,CAAMP,iBAAA,IAAiB/I,CAAA,GAAI6F;MAAA,GACpC1B,CAAA,CAAK0G,MAAA,GAASrB,CAAA,CAAMxB,OAAA,CAAQ6C,MAAA,CAAOC,MAAA,QAAS,KAEpDrL,CAAA;QACIqI,UAAA,EAAYqC,EAAA;QACZrK,KAAA,EAAKY,CAAA,KACE8I,CAAA,CAAMxB,OAAA,CAAQ3B,IAAA,EAAI;UACrBrH,IAAA,EAAiE,SAA7DoB,CAAA,GAAkC,SAAlCI,CAAA,GAAqB,SAArB5B,CAAA,GAAE0K,CAAA,CAAMyB,aAAA,IAAanM,CAAA,GAAIiG,CAAA,IAASrE,CAAA,GAAIgJ,CAAA,CAAMxB,OAAA,CAAQ3B,IAAA,CAAKrH,IAAA,IAAIoB,CAAA,GAAI;UACrE2H,gBAAA,EAAkBqC,EAAA;UAClBrK,aAAA,EAAe;UACfiL,UAAA,EAAY;QAAA,GACR7G,CAAA,CAAK0G,MAAA,GAASrB,CAAA,CAAMxB,OAAA,CAAQ6C,MAAA,CAAOxE,IAAA,QAAO;QAElD3H,CAAA,EAAGuL,EAAA;QACHrL,CAAA,EAAGsL,EAAA;QAAO/J,QAAA,EAETgE,CAAA,CAAK8G;MAAA;IAAA,EAItB;EAAA;ECnJaxG,CAAA,GAAY,SAAAyG,CAAH1M,CAAA;IA4BA,IA3BlBC,CAAA,GAAID,CAAA,CAAJkK,IAAA;MAEA/J,CAAA,GAACH,CAAA,CAADE,CAAA;MACAG,CAAA,GAACL,CAAA,CAADI,CAAA;MACAG,CAAA,GAASP,CAAA,CAAT6C,SAAA;MAASpC,CAAA,GAAAT,CAAA,CACT6D,OAAA;MAASlD,CAAA,QAAW,MAAHF,CAAA,GAAG,IAACA,CAAA;MACrBG,CAAA,GAAOZ,CAAA,CAAP8E,OAAA;MACAhE,CAAA,GAAOd,CAAA,CAAP4K,OAAA;MAEA7J,CAAA,GAASf,CAAA,CAAT+D,SAAA;MACAK,CAAA,GAAUpE,CAAA,CAAVgE,UAAA;MAAUK,CAAA,GAAArE,CAAA,CACV2M,aAAA;MAAA7M,CAAA,QAAgB,MAAHuE,CAAA,GAAG,kBAAeA,CAAA;MAAA7C,CAAA,GAAAxB,CAAA,CAC/B4D,YAAA;MAAAhC,CAAA,QAAe,MAAHJ,CAAA,GAAG,IAACA,CAAA;MAChBQ,CAAA,GAAahC,CAAA,CAAbuM,aAAA;MAAarK,CAAA,GAAAlC,CAAA,CACbiM,cAAA;MAAA7L,CAAA,QAAiB,MAAH8B,CAAA,GAAG,gBAAaA,CAAA;MAAAmB,CAAA,GAAArD,CAAA,CAC9BgM,WAAA;MAAA9L,CAAA,QAAc,MAAHmD,CAAA,GAAG,IAACA,CAAA;MAEfuB,CAAA,GAAW5E,CAAA,CAAXqK,WAAA;MACA9E,CAAA,GAAUvF,CAAA,CAAV+E,UAAA;MACAY,CAAA,GAAa3F,CAAA,CAAbgF,aAAA;MACAa,CAAA,GAAiB7F,CAAA,CAAjBsK,iBAAA;MACAxE,CAAA,GAAiB9F,CAAA,CAAjBuK,iBAAA;MAEAxE,CAAA,GAAO/F,CAAA,CAAPwK,OAAA;MACAvE,CAAA,GAAYjG,CAAA,CAAZyK,YAAA;MACApE,CAAA,GAAYrG,CAAA,CAAZ0K,YAAA;MACAlE,CAAA,GAAWxG,CAAA,CAAX2K,WAAA;MAEQlE,CAAA,GAAY/C,CAAA,CAAkB;QAClCI,SAAA,EAAW7D,CAAA,CAAKsC,MAAA;QAChBwB,SAAA,EAAAhD,CAAA;QACAiD,UAAA,EAAAI,CAAA;QACAR,YAAA,EAAAhC,CAAA;QACAiB,SAAA,EAAAtC,CAAA;QACAsD,OAAA,EAASlD;MAAA,GANLkD,OAAA;MASF6C,CAAA,GAAsB,UAAdnG,CAAA,GAAsBQ,CAAA,GAAYa,CAAA,GAAe;MACzD+E,CAAA,GAAsB,aAAdpG,CAAA,GAAyB6D,CAAA,GAAaxC,CAAA,GAAe;IAEnE,OACIX,CAAA;MAAGS,SAAA,EAAwB,eAAAvB,CAAA,GAAK,MAAAE,CAAA,GAAK;MAAAsB,QAAA,EAChC1B,CAAA,CAAKiJ,GAAA,CAAI,UAAClJ,CAAA,EAAMC,CAAA;QAAC,OACdgB,CAAA,CAAC+E,CAAA,EAAa;UAEVkE,IAAA,EAAMlK,CAAA;UACNE,CAAA,EAAGD,CAAA,GAAIyG,CAAA,GAAQD,CAAA,CAAQhD,IAAA;UACvBrD,CAAA,EAAGH,CAAA,GAAI0G,CAAA,GAAQF,CAAA,CAAQnD,GAAA;UACvBxB,KAAA,EAAOf,CAAA;UACPgB,MAAA,EAAQqC,CAAA;UACRvB,SAAA,EAAW/C,CAAA;UACXgF,OAAA,EAASlE,CAAA;UACTgK,OAAA,EAAS9J,CAAA;UACTqJ,SAAA,EAAWnI,CAAA;UACXoI,UAAA,EAAYhK,CAAA;UACZM,OAAA,EAASR,CAAA;UACTmK,WAAA,EAAazF,CAAA;UACbG,UAAA,EAAYQ,CAAA;UACZP,aAAA,EAAeW,CAAA;UACf2E,iBAAA,EAAmBzE,CAAA;UACnB0E,iBAAA,EAAmBzE,CAAA;UACnB0E,OAAA,EAASzE,CAAA;UACT0E,YAAA,EAAcxE,CAAA;UACdyE,YAAA,EAAcrE,CAAA;UACdsE,WAAA,EAAanE;QAAA,GApBRvG,CAAA;MAAA;IAAA,EAyBzB;EAAA;ECtEaoG,CAAA,GAAe,SAAAuG,CAAH5M,CAAA;IAgCA,IA/BrBC,CAAA,GAAID,CAAA,CAAJkK,IAAA;MAEA/J,CAAA,GAAcH,CAAA,CAAd0E,cAAA;MACArE,CAAA,GAAeL,CAAA,CAAf2E,eAAA;MAAepE,CAAA,GAAAP,CAAA,CACfwE,UAAA;MAAA/D,CAAA,QAAa,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAI,CAAA,GAAAX,CAAA,CACdyE,UAAA;MAAA7D,CAAA,QAAa,MAAHD,CAAA,GAAG,IAACA,CAAA;MACdG,CAAA,GAAMd,CAAA,CAANuE,MAAA;MACAxD,CAAA,GAASf,CAAA,CAAT6C,SAAA;MAASuB,CAAA,GAAApE,CAAA,CACT6D,OAAA;MAAAQ,CAAA,QAAU,MAAHD,CAAA,GAAG,IAACA,CAAA;MACXtE,CAAA,GAAOE,CAAA,CAAP8E,OAAA;MAAOtD,CAAA,GAAAxB,CAAA,CAEP4D,YAAA;MAAAhC,CAAA,QAAe,MAAHJ,CAAA,GAAG,IAACA,CAAA;MAChBQ,CAAA,GAAShC,CAAA,CAAT+D,SAAA;MACA7B,CAAA,GAAUlC,CAAA,CAAVgE,UAAA;MACA5D,CAAA,GAAaJ,CAAA,CAAb2M,aAAA;MACAtJ,CAAA,GAAarD,CAAA,CAAbuM,aAAA;MACA3H,CAAA,GAAc5E,CAAA,CAAdiM,cAAA;MACA1G,CAAA,GAAWvF,CAAA,CAAXgM,WAAA;MAEArG,CAAA,GAAW3F,CAAA,CAAXqK,WAAA;MACAxE,CAAA,GAAU7F,CAAA,CAAV+E,UAAA;MACAe,CAAA,GAAa9F,CAAA,CAAbgF,aAAA;MACAe,CAAA,GAAiB/F,CAAA,CAAjBsK,iBAAA;MACAtE,CAAA,GAAiBhG,CAAA,CAAjBuK,iBAAA;MAEAlE,CAAA,GAAOrG,CAAA,CAAPwK,OAAA;MACAhE,CAAA,GAAYxG,CAAA,CAAZyK,YAAA;MACAhE,CAAA,GAAYzG,CAAA,CAAZ0K,YAAA;MACAhE,CAAA,GAAW1G,CAAA,CAAX2K,WAAA;MAEAhE,CAAA,GAAO3G,CAAA,CAAP4K,OAAA;MAEAhE,CAAA,GAA0BlD,CAAA,CAAkB;QACxCI,SAAA,EAAW7D,CAAA,CAAKsC,MAAA;QAChBqB,YAAA,EAAAhC,CAAA;QACAmC,SAAA,EAAA/B,CAAA;QACAgC,UAAA,EAAA9B,CAAA;QACAW,SAAA,EAAA9B,CAAA;QACA8C,OAAA,EAAAQ;MAAA;MANIwC,CAAA,GAAKD,CAAA,CAAL9E,KAAA;MAAOgF,CAAA,GAAMF,CAAA,CAAN7E,MAAA;MASfgF,CAAA,GAAiB7G,CAAA,CAA0B;QACvCqE,MAAA,EAAAzD,CAAA;QACA0D,UAAA,EAAA/D,CAAA;QACAgE,UAAA,EAAA7D,CAAA;QACA8D,cAAA,EAAAvE,CAAA;QACAwE,eAAA,EAAAtE,CAAA;QACAyB,KAAA,EAAA+E,CAAA;QACA9E,MAAA,EAAA+E;MAAA;MAPIE,CAAA,GAACD,CAAA,CAAD7G,CAAA;MAAG+G,CAAA,GAACF,CAAA,CAAD3G,CAAA;IAUX,OACIa,CAAA,CAACgF,CAAA,EAAS;MACNiE,IAAA,EAAMjK,CAAA;MACNC,CAAA,EAAG8G,CAAA;MACH5G,CAAA,EAAG6G,CAAA;MACHpE,SAAA,EAAW9B,CAAA;MACX8C,OAAA,EAASQ,CAAA;MACTS,OAAA,EAAShF,CAAA;MACT8K,OAAA,EAASjE,CAAA;MACT/C,YAAA,EAAchC,CAAA;MACdmC,SAAA,EAAW/B,CAAA;MACXgC,UAAA,EAAY9B,CAAA;MACZyK,aAAA,EAAevM,CAAA;MACfmM,aAAA,EAAelJ,CAAA;MACf4I,cAAA,EAAgBrH,CAAA;MAChBoH,WAAA,EAAazG,CAAA;MACb8E,WAAA,EAAa1E,CAAA;MACbZ,UAAA,EAAYc,CAAA;MACZb,aAAA,EAAec,CAAA;MACfwE,iBAAA,EAAmBvE,CAAA;MACnBwE,iBAAA,EAAmBvE,CAAA;MACnBwE,OAAA,EAASnE,CAAA;MACToE,YAAA,EAAcjE,CAAA;MACdkE,YAAA,EAAcjE,CAAA;MACdkE,WAAA,EAAoC,oBAAhBjE,CAAA,QAA4B,IAAYA;IAAA,EAGxE;EAAA;ECzEMF,CAAA,GAAmB;IACrBqG,KAAA,EAAO;IACPC,MAAA,EAAQ;IACRC,GAAA,EAAK;EAAA;EAGItG,CAAA,GAAuB,SAAAuG,CAChC/L,CAAA,EAA6BjB,CAAA;IA4B5B,IA1BGC,CAAA,GAAID,CAAA,CAAJkK,IAAA;MAEA/J,CAAA,GAAcH,CAAA,CAAd0E,cAAA;MACArE,CAAA,GAAeL,CAAA,CAAf2E,eAAA;MAAepE,CAAA,GAAAP,CAAA,CACfwE,UAAA;MAAA/D,CAAA,QAAa,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAI,CAAA,GAAAX,CAAA,CACdyE,UAAA;MAAA7D,CAAA,QAAa,MAAHD,CAAA,GAAG,IAACA,CAAA;MACdG,CAAA,GAAMd,CAAA,CAANuE,MAAA;MACAxD,CAAA,GAASf,CAAA,CAAT6C,SAAA;MAASuB,CAAA,GAAApE,CAAA,CACT6D,OAAA;MAASQ,CAAA,QAAW,MAAHD,CAAA,GAAG,IAACA,CAAA;MAAAtE,CAAA,GAAAE,CAAA,CACrB8E,OAAA;MAAAtD,CAAA,QAAU,MAAH1B,CAAA,IAAQA,CAAA;MAAA8B,CAAA,GAAA5B,CAAA,CAGf4D,YAAA;MAAA5B,CAAA,QAAe,MAAHJ,CAAA,GAAG,IAACA,CAAA;MAChBM,CAAA,GAASlC,CAAA,CAAT+D,SAAA;MACA3D,CAAA,GAAUJ,CAAA,CAAVgE,UAAA;MAAUX,CAAA,GAAArD,CAAA,CACV2M,aAAA;MAAApH,CAAA,QAAgB,MAAHlC,CAAA,GAAG,kBAAeA,CAAA;MAC/BsC,CAAA,GAAa3F,CAAA,CAAbuM,aAAA;MAAa1G,CAAA,GAAA7F,CAAA,CAGb+E,UAAA;MAAAe,CAAA,QAAa,MAAHD,CAAA,GAAG,KAAEA,CAAA;MAAAE,CAAA,GAAA/F,CAAA,CACfgF,aAAA;MAAAgB,CAAA,QAAgB,MAAHD,CAAA,GAAG,IAACA,CAAA;MAIjBE,CAAA,GAAKjG,CAAA,CAALiN,KAAA;MAGJ5G,CAAA,GAAmC3C,CAAA,CAAkB;QACjDI,SAAA,EAAW7D,CAAA,CAAKsC,MAAA;QAChBwB,SAAA,EAAA7B,CAAA;QACA8B,UAAA,EAAA5D,CAAA;QACAwD,YAAA,EAAA5B,CAAA;QACAa,SAAA,EAAA9B,CAAA;QACA8C,OAAA,EAASQ;MAAA;MANLoC,CAAA,GAAKJ,CAAA,CAALvE,KAAA;MAAO4E,CAAA,GAAML,CAAA,CAANtE,MAAA;MAAQ4E,CAAA,GAAON,CAAA,CAAPxC,OAAA;MASvB+C,CAAA,GAAiB1G,CAAA,CAA0B;QACvCqE,MAAA,EAAAzD,CAAA;QACA0D,UAAA,EAAA/D,CAAA;QACAgE,UAAA,EAAA7D,CAAA;QACA8D,cAAA,EAAAvE,CAAA;QACAwE,eAAA,EAAAtE,CAAA;QACAyB,KAAA,EAAA2E,CAAA;QACA1E,MAAA,EAAA2E;MAAA;MAPIG,CAAA,GAACD,CAAA,CAAD1G,CAAA;MAAG4G,CAAA,GAACF,CAAA,CAADxG,CAAA;MAUL2G,CAAA,GAAsB,UAAdhG,CAAA,GAAsBmB,CAAA,GAAYF,CAAA,GAAe;MACzDgF,CAAA,GAAsB,aAAdjG,CAAA,GAAyBX,CAAA,GAAa4B,CAAA,GAAe;IAEnEf,CAAA,CAAIiM,IAAA,IACJjM,CAAA,CAAIkM,SAAA,CAAUtG,CAAA,EAAGC,CAAA,GAEjB7F,CAAA,CAAImM,IAAA,GAAUnH,CAAA,CAAMuD,OAAA,CAAQ3B,IAAA,CAAKwF,QAAA,YAAcpH,CAAA,CAAMuD,OAAA,CAAQ3B,IAAA,CAAKyF,UAAA,IAAc,eAEhFrN,CAAA,CAAKsH,OAAA,CAAQ,UAACvH,CAAA,EAAGC,CAAA;MAAM,IAAAE,CAAA;QAAAE,CAAA;QACbE,CAAA,GAAQN,CAAA,GAAI8G,CAAA,GAAQJ,CAAA,CAAQlD,IAAA;QAC5BhD,CAAA,GAAQR,CAAA,GAAI+G,CAAA,GAAQL,CAAA,CAAQrD,GAAA;QAElC3C,CAAA,GAA0EiE,CAAA,CACtE;UACI/B,SAAA,EAAW0C,CAAA;UACXT,OAAA,EAAAtD,CAAA;UACAuD,UAAA,EAAAe,CAAA;UACAd,aAAA,EAAAgB,CAAA;UACAlE,KAAA,EAAOI,CAAA;UACPH,MAAA,EAAQ3B;QAAA;QAPRQ,CAAA,GAAOD,CAAA,CAAPsE,OAAA;QAASnE,CAAA,GAAOH,CAAA,CAAPuE,OAAA;QAASnE,CAAA,GAAMJ,CAAA,CAANwE,MAAA;QAAQf,CAAA,GAAMzD,CAAA,CAANyE,MAAA;QAAQf,CAAA,GAAW1D,CAAA,CAAX0E,WAAA;QAAavF,CAAA,GAAca,CAAA,CAAd2E,cAAA;MAWvDrE,CAAA,CAAIsM,SAAA,GAAmB,SAAVpN,CAAA,GAAGH,CAAA,CAAEoM,KAAA,IAAKjM,CAAA,GAAI,SAC3Bc,CAAA,CAAIuM,QAAA,CAASjN,CAAA,GAAQK,CAAA,EAASH,CAAA,GAAQK,CAAA,EAASgF,CAAA,EAAYA,CAAA,GAE3D7E,CAAA,CAAIwM,SAAA,GAAYjH,CAAA,CAAiBnC,CAAA,GAEV,cAAnBvE,CAAA,KACAmB,CAAA,CAAIyM,YAAA,GAAe,WAGvBzM,CAAA,CAAIsM,SAAA,GAAoD,SAA3ClN,CAAA,WAAGsF,CAAA,GAAAA,CAAA,GAAiBM,CAAA,CAAMuD,OAAA,CAAQ3B,IAAA,CAAKrH,IAAA,IAAIH,CAAA,GAAI,SAC5DY,CAAA,CAAI0M,QAAA,CAASC,MAAA,CAAO5N,CAAA,CAAEyM,KAAA,GAAQlM,CAAA,GAAQQ,CAAA,EAAQN,CAAA,GAAQ2D,CAAA,CAC1D;IAAA,IAEAnD,CAAA,CAAI4M,OAAA,EACR;EAAA;EAEanH,CAAA,GAAsC,SAAAoH,CAC/C7M,CAAA,EAA6BjB,CAAA;IAwB5B,IAtBGC,CAAA,GAAcD,CAAA,CAAd0E,cAAA;MACAvE,CAAA,GAAeH,CAAA,CAAf2E,eAAA;MACAtE,CAAA,GAAML,CAAA,CAANuE,MAAA;MAAM9D,CAAA,GAAAT,CAAA,CACNwE,UAAA;MAAA7D,CAAA,QAAa,MAAHF,CAAA,GAAG,IAACA,CAAA;MAAAG,CAAA,GAAAZ,CAAA,CACdyE,UAAA;MAAA3D,CAAA,QAAa,MAAHF,CAAA,GAAG,IAACA,CAAA;MACdG,CAAA,GAAKf,CAAA,CAALyF,KAAA;MAAKrB,CAAA,GAAApE,CAAA,CACLuC,MAAA;MAAA8B,CAAA,QAAM,MAAAD,CAAA,GAAGhE,CAAA,CAA+BmC,MAAA,GAAM6B,CAAA;MAAAtE,CAAA,GAAAE,CAAA,CAC9C4C,SAAA;MAAApB,CAAA,QAAS,MAAA1B,CAAA,GAAGM,CAAA,CAA+BwC,SAAA,GAAS9C,CAAA;MAAA8B,CAAA,GAAA5B,CAAA,CACpD6C,SAAA;MAAAb,CAAA,QAAS,MAAAJ,CAAA,GAAGxB,CAAA,CAA+ByC,SAAA,GAASjB,CAAA;MAC7CM,CAAA,GAAMlC,CAAA,CAAb0F,KAAA;MAAKrC,CAAA,GAAArD,CAAA,CACL8C,YAAA;MAAAY,CAAA,QAAY,MAAAL,CAAA,GAAGjD,CAAA,CAA+B0C,YAAA,GAAYO,CAAA;MAAAuB,CAAA,GAAA5E,CAAA,CAC1D+C,QAAA;MAAA4C,CAAA,QAAQ,MAAAf,CAAA,GAAGxE,CAAA,CAA+B2C,QAAA,GAAQ6B,CAAA;MAAAiB,CAAA,GAAA7F,CAAA,CAClDgD,WAAA;MAAA8C,CAAA,QAAW,MAAAD,CAAA,GAAGzF,CAAA,CAA+B4C,WAAA,GAAW6C,CAAA;MAAAE,CAAA,GAAA/F,CAAA,CACxDiD,WAAA;MAAA+C,CAAA,QAAW,MAAAD,CAAA,GAAG3F,CAAA,CAA+B6C,WAAA,GAAW8C,CAAA;MAAAE,CAAA,GAAAjG,CAAA,CACxDkD,UAAA;MAAAmD,CAAA,QAAU,MAAAJ,CAAA,GAAG7F,CAAA,CAA+B8C,UAAA,GAAU+C,CAAA;MACtDO,CAAA,GAAKxG,CAAA,CAAL4F,KAAA;MAAKa,CAAA,GAAAzG,CAAA,CACLmD,UAAA;MAAAuD,CAAA,QAAU,MAAAD,CAAA,GAAGrG,CAAA,CAA+B+C,UAAA,GAAUsD,CAAA;MAAAE,CAAA,GAAA3G,CAAA,CACtDoD,WAAA;MAAAwD,CAAA,QAAW,MAAAD,CAAA,GAAGvG,CAAA,CAA+BgD,WAAA,GAAWuD,CAAA;MACxDE,CAAA,GAAK7G,CAAA,CAALiN,KAAA;MAKJnG,CAAA,GAeIvB,CAAA,CAA8B;QAC9BE,KAAA,EAAA1E,CAAA;QACA2E,KAAA,EAAOxD,CAAA;QACPK,MAAA,EAAA8B,CAAA;QACAzB,SAAA,EAAApB,CAAA;QACAqB,SAAA,EAAAb,CAAA;QACAc,YAAA,EAAAY,CAAA;QACAX,QAAA,EAAA4C,CAAA;QACA3C,WAAA,EAAA8C,CAAA;QACA7C,WAAA,EAAA+C,CAAA;QACA9C,UAAA,EAAAmD,CAAA;QACAT,KAAA,EAAAY,CAAA;QACArD,UAAA,EAAAuD,CAAA;QACAtD,WAAA,EAAAwD;MAAA;MA3BAG,CAAA,GAAKD,CAAA,CAALhF,KAAA;MACAkF,CAAA,GAAMF,CAAA,CAAN/E,MAAA;MACAkF,CAAA,GAAUH,CAAA,CAAVwB,UAAA;MACApB,CAAA,GAAUJ,CAAA,CAAVyB,UAAA;MACApB,CAAA,GAAUL,CAAA,CAAV0B,UAAA;MACApB,CAAA,GAAUN,CAAA,CAAV2B,UAAA;MACApB,CAAA,GAAUP,CAAA,CAAV4B,UAAA;MACApB,CAAA,GAAKR,CAAA,CAALpB,KAAA;MACAwC,CAAA,GAASpB,CAAA,CAAT6B,SAAA;MACAR,CAAA,GAAMrB,CAAA,CAAN8B,MAAA;MACAR,CAAA,GAAMtB,CAAA,CAAN+B,MAAA;MACAR,CAAA,GAAavB,CAAA,CAAbgC,aAAA;MACA+B,CAAA,GAAkB/D,CAAA,CAAlBkC,kBAAA;MACA8B,CAAA,GAAoBhE,CAAA,CAApBiC,oBAAA;MAiBJgC,CAAA,GAAiB7K,CAAA,CAA0B;QACvCqE,MAAA,EAAAlE,CAAA;QACAmE,UAAA,EAAA7D,CAAA;QACA8D,UAAA,EAAA3D,CAAA;QACA4D,cAAA,EAAAzE,CAAA;QACA0E,eAAA,EAAAxE,CAAA;QACA2B,KAAA,EAAAiF,CAAA;QACAhF,MAAA,EAAAiF;MAAA;MAPIgE,CAAA,GAACD,CAAA,CAAD7K,CAAA;MAAG+K,EAAA,GAACF,CAAA,CAAD3K,CAAA;MAULiL,EAAA,GAAgB;QAClB+B,IAAA,EAAMnM,CAAA,CAAImM,IAAA;QACVK,SAAA,EAAWxM,CAAA,CAAIwM,SAAA;QACfC,YAAA,EAAczM,CAAA,CAAIyM;MAAA;IAEtBzM,CAAA,CAAIiM,IAAA,IAEJjM,CAAA,CAAIkM,SAAA,CAAUnC,CAAA,EAAGC,EAAA;IAEjB,IAAMK,EAAA,GAAWrK,CAAA,CAAI8M,oBAAA,CACjB9G,CAAA,GAAaF,CAAA,EACbG,CAAA,GAAaF,CAAA,EACbG,CAAA,GAAaJ,CAAA,EACbK,CAAA,GAAaJ,CAAA;IAEjBK,CAAA,CAAWE,OAAA,CAAQ,UAAAtG,CAAA;MACfqK,EAAA,CAAS0C,YAAA,CAAa/M,CAAA,CAAUkI,MAAA,EAAQlI,CAAA,CAAUgN,SAAA,CACtD;IAAA,IAEAhN,CAAA,CAAIsM,SAAA,GAAYjC,EAAA,EAChBrK,CAAA,CAAIuM,QAAA,CAAS,GAAG,GAAGzG,CAAA,EAAOC,CAAA,GAE1B/F,CAAA,CAAImM,IAAA,IACAvG,CAAA,CAAM2C,OAAA,CAAQ9D,KAAA,CAAMmC,IAAA,CAAKqG,UAAA,GAAgBrH,CAAA,CAAM2C,OAAA,CAAQ9D,KAAA,CAAMmC,IAAA,CAAKqG,UAAA,GAAgB,YACnFrH,CAAA,CAAM2C,OAAA,CAAQ9D,KAAA,CAAMmC,IAAA,CAAKwF,QAAA,GAAc,QAAAxG,CAAA,CAAM2C,OAAA,CAAQ9D,KAAA,CAAMmC,IAAA,CAAKyF,UAAA,EAEnEhG,CAAA,CAAMC,OAAA,CAAQ,UAAAvH,CAAA;MAAQ,IAAAC,CAAA;MAAA,CACuB,SAArCA,CAAA,GAAC4G,CAAA,CAAM2C,OAAA,CAAQ9D,KAAA,CAAM+D,IAAA,CAAKrI,WAAA,IAAWnB,CAAA,GAAI,KAAK,MAC9CgB,CAAA,CAAIkN,SAAA,GAAYC,MAAA,CAAOvH,CAAA,CAAMwH,IAAA,CAAK3I,KAAA,CAAM+D,IAAA,CAAKrI,WAAA,GACzCyF,CAAA,CAAMwH,IAAA,CAAK3I,KAAA,CAAM+D,IAAA,CAAKpI,MAAA,KACtBJ,CAAA,CAAIqN,WAAA,GAAczH,CAAA,CAAMwH,IAAA,CAAK3I,KAAA,CAAM+D,IAAA,CAAKpI,MAAA,GAE5CJ,CAAA,CAAIsN,OAAA,GAAU,UAEdtN,CAAA,CAAIuN,SAAA,IACJvN,CAAA,CAAIwN,MAAA,CAAOzO,CAAA,CAAKyH,EAAA,EAAIzH,CAAA,CAAK0H,EAAA,GACzBzG,CAAA,CAAIyN,MAAA,CAAO1O,CAAA,CAAK2H,EAAA,EAAI3H,CAAA,CAAK4H,EAAA,GACzB3G,CAAA,CAAII,MAAA,KAGJwF,CAAA,CAAM2C,OAAA,CAAQ9D,KAAA,CAAMmC,IAAA,CAAKrH,IAAA,KACzBS,CAAA,CAAIsM,SAAA,GAAY1G,CAAA,CAAM2C,OAAA,CAAQ9D,KAAA,CAAMmC,IAAA,CAAKrH,IAAA,GAE7CS,CAAA,CAAIwM,SAAA,GAAyC,aAA7BzN,CAAA,CAAKgI,mBAAA,GAAmC,WAAWhI,CAAA,CAAKgI,mBAAA,EACxE/G,CAAA,CAAIyM,YAAA,GAA0C,cAA3B1N,CAAA,CAAKiI,iBAAA,GAAkC,WAAWjI,CAAA,CAAKiI,iBAAA,EAE1EhH,CAAA,CAAI0M,QAAA,CAAS3N,CAAA,CAAK6H,IAAA,EAAM7H,CAAA,CAAK8H,KAAA,EAAO9H,CAAA,CAAK+H,KAAA,CAC7C;IAAA,IAEIG,CAAA,KACAjH,CAAA,CAAIiM,IAAA,IACJjM,CAAA,CAAIkM,SAAA,CAAUhF,CAAA,EAAQC,CAAA,GACtBnH,CAAA,CAAI0N,MAAA,CAAOpO,CAAA,CAAiB8H,CAAA,IAE5BpH,CAAA,CAAImM,IAAA,IACAvG,CAAA,CAAM2C,OAAA,CAAQ5D,KAAA,CAAMiC,IAAA,CAAKqG,UAAA,GAAgBrH,CAAA,CAAM2C,OAAA,CAAQ5D,KAAA,CAAMiC,IAAA,CAAKqG,UAAA,GAAgB,YACnFrH,CAAA,CAAM2C,OAAA,CAAQ5D,KAAA,CAAMiC,IAAA,CAAKwF,QAAA,GAAc,QAAAxG,CAAA,CAAM2C,OAAA,CAAQ5D,KAAA,CAAMiC,IAAA,CAAKyF,UAAA,EAC/DzG,CAAA,CAAM2C,OAAA,CAAQ5D,KAAA,CAAMiC,IAAA,CAAKrH,IAAA,KACzBS,CAAA,CAAIsM,SAAA,GAAY1G,CAAA,CAAM2C,OAAA,CAAQ5D,KAAA,CAAMiC,IAAA,CAAKrH,IAAA,GAE7CS,CAAA,CAAIwM,SAAA,GAAqC,aAAzB3C,CAAA,GAAoC,WAAWA,CAAA,EAC/D7J,CAAA,CAAIyM,YAAA,GAAe7C,CAAA,EAEnB5J,CAAA,CAAI0M,QAAA,CAASzF,CAAA,EAAW,GAAG,IAE3BjH,CAAA,CAAI4M,OAAA,KAGR5M,CAAA,CAAI4M,OAAA,IAEJ5M,CAAA,CAAImM,IAAA,GAAO/B,EAAA,CAAc+B,IAAA,EACzBnM,CAAA,CAAIwM,SAAA,GAAYpC,EAAA,CAAcoC,SAAA,EAC9BxM,CAAA,CAAIyM,YAAA,GAAerC,EAAA,CAAcqC,YACrC;EAAA;EC5Oa/G,CAAA,GAAkC,SAAAiI,CAAH3N,CAAA;IAYtC,IAXFjB,CAAA,GAAKiB,CAAA,CAALwE,KAAA;MACQxF,CAAA,GAAgBgB,CAAA,CAAxBkF,MAAA;MAAMhG,CAAA,GAAAc,CAAA,CACNmF,OAAA;MAAA/F,CAAA,QAAU,MAAHF,CAAA,IAAQA,CAAA;MAAAI,CAAA,GAAAU,CAAA,CACf4N,WAAA;MAAApO,CAAA,QAAc,MAAHF,CAAA,GAAG,UAAAU,CAAA;QAAC,OAAIA,CAAC;MAAA,IAAAV,CAAA;MAAAI,CAAA,GAAAM,CAAA,CACpB6N,SAAA;MAAAlO,CAAA,QAAY,MAAHD,CAAA,GAAG,QAAKA,CAAA;IAQjB,OAAOyD,CAAA,CAAQ;MACX,IAEMnD,CAAA,IAFS,QAAAhB,CAAA,GAAAA,CAAA,GAAoBD,CAAA,CAAMsG,KAAA,IAEpB4C,GAAA,CAAI,UAACjI,CAAA,EAAahB,CAAA;QACnC,IAAAE,CAAA,GAAqBH,CAAA,CAAM+O,YAAA,CAAa9N,CAAA;UAAjCZ,CAAA,GAAKF,CAAA;UAAEI,CAAA,GAAGJ,CAAA;QAEjB,OAAO;UACHkJ,EAAA,EAAIpI,CAAA;UACJ+N,KAAA,EAAA/O,CAAA;UACAgP,MAAA,EAAQ,CAAC5O,CAAA,EAAOE,CAAA;UAChBkM,KAAA,EAAK,KAAKhM,CAAA,CAAYJ,CAAA,IAASO,CAAA,GAAYH,CAAA,CAAYF,CAAA;UACvD2O,KAAA,EAAOlP,CAAA,CAAMK,CAAA;UACb+L,KAAA,EAAOnL;QAAA,CAEf;MAAA;MAIA,OAFIZ,CAAA,IAASY,CAAA,CAAMmF,OAAA,IAEZnF,CACX;IAAA,GAAG,CAAChB,CAAA,EAAkBD,CAAA,EAAOK,CAAA,EAASO,CAAA,EAAWH,CAAA,EACrD;EAAA;ECzBamG,CAAA,GAAkB;IAC3BsD,IAAA,EAAM7F,CAAA,CAAU8K,OAAA,CAAQ9K,CAAA,CAAU+K,MAAA;IAGlC7K,MAAA,EAAQF,CAAA,CAAUgL,KAAA,CAAM,CACpB,OACA,aACA,SACA,gBACA,UACA,eACA,QACA,YACA,WACDC,UAAA;IACH9K,UAAA,EAAYH,CAAA,CAAUkL,MAAA;IACtB9K,UAAA,EAAYJ,CAAA,CAAUkL,MAAA;IACtB1M,SAAA,EAAWwB,CAAA,CAAUgL,KAAA,CAAM,CAAC,OAAO,WAAWC,UAAA;IAG9C1L,YAAA,EAAcS,CAAA,CAAUkL,MAAA;IACxBxL,SAAA,EAAWM,CAAA,CAAUkL,MAAA,CAAOD,UAAA;IAC5BtL,UAAA,EAAYK,CAAA,CAAUkL,MAAA,CAAOD,UAAA;IAC7B3C,aAAA,EAAetI,CAAA,CAAUgL,KAAA,CAAM,CAC3B,iBACA,iBACA,iBACA;IAEJ9C,aAAA,EAAelI,CAAA,CAAUmL,MAAA;IACzBvD,cAAA,EAAgB5H,CAAA,CAAUmL,MAAA;IAC1BxD,WAAA,EAAa3H,CAAA,CAAUkL,MAAA;IAEvBlF,WAAA,EAAahG,CAAA,CAAUoL,SAAA,CAAU,CAC7BpL,CAAA,CAAUgL,KAAA,CAAM,CAAC,UAAU,WAAW,UAAU,cAChDhL,CAAA,CAAUqL,IAAA;IAEd3K,UAAA,EAAYV,CAAA,CAAUkL,MAAA;IACtBvK,aAAA,EAAeX,CAAA,CAAUkL,MAAA;IACzBjF,iBAAA,EAAmBjG,CAAA,CAAUkL,MAAA;IAC7BhF,iBAAA,EAAmBlG,CAAA,CAAUmL,MAAA;IAE7BhF,OAAA,EAASnG,CAAA,CAAUqL,IAAA;IACnBjF,YAAA,EAAcpG,CAAA,CAAUqL,IAAA;IACxBhF,YAAA,EAAcrG,CAAA,CAAUqL,IAAA;IAExB9E,OAAA,EAASvG,CAAA,CAAU8K,OAAA,CACf9K,CAAA,CAAUsL,KAAA,CAAM;MACZxE,EAAA,EAAI9G,CAAA,CAAUoL,SAAA,CAAU,CAACpL,CAAA,CAAUgL,KAAA,CAAM,CAAC,YAAYC,UAAA;MACtDhO,KAAA,EAAO+C,CAAA,CAAUsL,KAAA,CAAM;QACnBpD,aAAA,EAAelI,CAAA,CAAUmL,MAAA;QACzBvD,cAAA,EAAgB5H,CAAA,CAAUmL,MAAA;QAC1BxD,WAAA,EAAa3H,CAAA,CAAUkL,MAAA;QACvBxK,UAAA,EAAYV,CAAA,CAAUkL,MAAA;QACtBjF,iBAAA,EAAmBjG,CAAA,CAAUkL,MAAA;QAC7BhF,iBAAA,EAAmBlG,CAAA,CAAUmL;MAAA,GAC9BF;IAAA;EAAA;AAAA,SAAAxJ,CAAA,IAAA4D,iCAAA,EAAArD,CAAA,IAAAuG,YAAA,EAAAjH,CAAA,IAAAsD,yBAAA,EAAArC,CAAA,IAAAgJ,eAAA,EAAA3J,CAAA,IAAAyG,SAAA,EAAA1G,CAAA,IAAAiE,aAAA,EAAAnK,CAAA,IAAAC,YAAA,EAAAyB,CAAA,IAAAC,aAAA,EAAAG,CAAA,IAAAC,YAAA,EAAAG,CAAA,IAAAC,cAAA,EAAAsD,CAAA,IAAAC,6BAAA,EAAA9B,CAAA,IAAAC,iBAAA,EAAAiB,CAAA,IAAAC,iBAAA,EAAA3E,CAAA,IAAAoE,yBAAA,EAAAlE,CAAA,IAAAyP,8BAAA,EAAAnJ,CAAA,IAAAoH,mCAAA,EAAArH,CAAA,IAAAuG,oBAAA,EAAArG,CAAA,IAAAiI,+BAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}